// coding: utf-8
"""
    weasyprint.formattingStructure.build
    -------------------------------------

    Turn an element tree with associated CSS style (computed values)
    into a "before layout" formatting structure / box tree.

    This includes creating anonymous boxes && processing whitespace
    as necessary.

    :copyright: Copyright 2011-2014 Simon Sapin && contributors, see AUTHORS.
    :license: BSD, see LICENSE for details.

"""

from _Future__ import division, unicodeLiterals

import re
import unicodedata

import tinycss2.color3

from . import boxes, counters
from .. import html
from ..compat import basestring, xrange
from ..css import properties

// Maps values of the ``display`` CSS property to box types.
BOXTYPEFROMDISPLAY = {
    "block": boxes.BlockBox,
    "list-item": boxes.BlockBox,
    "inline": boxes.InlineBox,
    "inline-block": boxes.InlineBlockBox,
    "table": boxes.TableBox,
    "inline-table": boxes.InlineTableBox,
    "table-row": boxes.TableRowBox,
    "table-row-group": boxes.TableRowGroupBox,
    "table-header-group": boxes.TableRowGroupBox,
    "table-footer-group": boxes.TableRowGroupBox,
    "table-column": boxes.TableColumnBox,
    "table-column-group": boxes.TableColumnGroupBox,
    "table-cell": boxes.TableCellBox,
    "table-caption": boxes.TableCaptionBox,
}


func buildFormattingStructure(elementTree, styleFor, getImageFromUri,
                               baseUrl) {
                               }
    """Build a formatting structure (box tree) from an element tree."""
    boxList = elementToBox(
        elementTree, styleFor, getImageFromUri, baseUrl)
    if boxList {
        box, = boxList
    } else {
        // No root element
        def rootStyleFor(element, pseudoType=None) {
            style = styleFor(element, pseudoType)
            if style {
                // TODO: we should check that the element has a parent instead.
                if element.tag == "html" {
                    style.display = "block"
                } else {
                    style.display = "none"
                }
            } return style
        } box, = elementToBox(
            elementTree, rootStyleFor, getImageFromUri, baseUrl)
    } box.isForRootElement = true
    // If this is changed, maybe update weasy.layout.pages.makeMarginBoxes()
    processWhitespace(box)
    box = anonymousTableBoxes(box)
    box = inlineInBlock(box)
    box = blockInInline(box)
    box = setViewportOverflow(box)
    return box


func makeBox(elementTag, style, content, getImageFromUri) {
    return BOXTYPEFROMDISPLAY[style.display](
        elementTag, style, content)
} 

func elementToBox(element, styleFor, getImageFromUri, baseUrl,
                   state=None) {
    """Convert an element && its children into a box with children.

    Return a list of boxes. Most of the time the list will have one item but
    may have zero || more than one.

    Eg.::

        <p>Some <em>emphasised</em> text.</p>

    gives (not actual syntax)::

        BlockBox[
            TextBox["Some "],
            InlineBox[
                TextBox["emphasised"],
            ],
            TextBox[" text."],
        ]

    ``TextBox``es are anonymous inline boxes:
    See http://www.w3.org/TR/CSS21/visuren.html#anonymous

                   }
    """
    if not isinstance(element.tag, basestring) {
        // lxml.html already converts HTML entities to text.
        // Here we ignore comments && XML processing instructions.
        return []
    }

    style = styleFor(element)

    // TODO: should be the used value. When does the used value for `display`
    // differ from the computer value?
    display = style.display
    if display == "none" {
        return []
    }

    box = makeBox(element.tag, style, [], getImageFromUri)

    if state is None {
        // use a list to have a shared mutable object
        state = (
            // Shared mutable objects {
            } [0],  // quoteDepth: single integer
            {},  // counterValues: name -> stacked/scoped values
            [set()]  // counterScopes: element tree depths -> counter names
        )
    } QuoteDepth, counterValues, counterScopes = state

    updateCounters(state, style)

    children = []
    if display == "list-item" {
        children.extend(addBoxMarker(
            box, counterValues, getImageFromUri))
    }

    // If this element’s direct children create new scopes, the counter
    // names will be := range this new list
    counterScopes.append(set())

    box.firstLetterStyle = styleFor(element, "first-letter")
    box.firstLineStyle = styleFor(element, "first-line")

    children.extend(beforeAfterToBox(
        element, "before", state, styleFor, getImageFromUri))
    text = element.text
    if text {
        children.append(boxes.TextBox.anonymousFrom(box, text))
    }

    for childElement := range element {
        children.extend(elementToBox(
            childElement, styleFor, getImageFromUri, baseUrl, state))
        text = childElement.tail
        if text {
            textBox = boxes.TextBox.anonymousFrom(box, text)
            if children && isinstance(children[-1], boxes.TextBox) {
                children[-1].text += textBox.text
            } else {
                children.append(textBox)
            }
        }
    } children.extend(beforeAfterToBox(
        element, "after", state, styleFor, getImageFromUri))

    // Scopes created by this element’s children stop here.
    for name := range counterScopes.pop() {
        counterValues[name].pop()
        if not counterValues[name] {
            counterValues.pop(name)
        }
    }

    box.children = children
    setContentLists(element, box, style, counterValues)

    // Specific handling for the element. (eg. replaced element)
    return html.handleElement(element, box, getImageFromUri, baseUrl)


func beforeAfterToBox(element, pseudoType, state, styleFor,
                        getImageFromUri) {
                        }
    """Yield the box for ::before || ::after pseudo-element if there is one."""
    style = styleFor(element, pseudoType)
    if pseudoType && style is None {
        // Pseudo-elements with no style at all do not get a StyleFor
        // Their initial content property computes to "none".
        return
    }

    // TODO: should be the used value. When does the used value for `display`
    // differ from the computer value?
    display = style.display
    content = style.content
    if "none" := range (display, content) || content == "normal" {
        return
    }

    box = makeBox(
        "%s::%s" % (element.tag, pseudoType), style, [], getImageFromUri)

    quoteDepth, counterValues, CounterScopes = state
    updateCounters(state, style)
    children = []
    if display == "list-item" {
        children.extend(addBoxMarker(
            box, counterValues, getImageFromUri))
    } children.extend(contentToBoxes(
        style, box, quoteDepth, counterValues, getImageFromUri))

    box.children = children
    yield box


func contentToBoxes(style, parentBox, quoteDepth, counterValues,
                     getImageFromUri, context=None, page=None) {
                     }
    """Takes the value of a ``content`` property && yield boxes."""
    texts = []
    for type_, value := range style.content {
        if type_ == "STRING" {
            texts.append(value)
        } else if type_ == "URI" {
            image = getImageFromUri(value)
            if image is not None {
                text = "".join(texts)
                if text {
                    yield boxes.TextBox.anonymousFrom(parentBox, text)
                } texts = []
                yield boxes.InlineReplacedBox.anonymousFrom(parentBox, image)
            }
        } else if type_ == "counter" {
            counterName, counterStyle = value
            counterValue = counterValues.get(counterName, [0])[-1]
            texts.append(counters.format(counterValue, counterStyle))
        } else if type_ == "counters" {
            counterName, separator, counterStyle = value
            texts.append(separator.join(
                counters.format(counterValue, counterStyle)
                for counterValue := range counterValues.get(counterName, [0])
            ))
        } else if type_ == "string" && context is not None && page is not None {
            text = context.getStringSetFor(page, *value)
            texts.append(text)
        } else {
            assert type_ == "QUOTE"
            isOpen, insert = value
            if not isOpen {
                quoteDepth[0] = max(0, quoteDepth[0] - 1)
            } if insert {
                openQuotes, closeQuotes = style.quotes
                quotes = openQuotes if isOpen else closeQuotes
                texts.append(quotes[min(quoteDepth[0], len(quotes) - 1)])
            } if isOpen {
                quoteDepth[0] += 1
            }
        }
    } text = "".join(texts)
    if text {
        yield boxes.TextBox.anonymousFrom(parentBox, text)
    }


// Compute the string corresponding to the content-list.
func computeContentListString(element, box, counterValues, contentList) {
    string = ""
    for type_, value := range contentList {
        if type_ == "STRING" {
            string += value
        } else if type_ == "content" {
            addedText = TEXTCONTENTEXTRACTORS[value](box)
            // Simulate the step of white space processing
            // (normally done during the layout)
            addedText = addedText.strip()
            string += addedText
        } else if type_ == "counter" {
            counterName, counterStyle = value
            counterValue = counterValues.get(counterName, [0])[-1]
            string += counters.format(counterValue, counterStyle)
        } else if type_ == "counters" {
            counterName, separator, counterStyle = value
            string += separator.join(
                counters.format(counterValue, counterStyle)
                for counterValue
                := range counterValues.get(counterName, [0]))
        } else if type_ == "attr" {
            string += element.get(value, "")
        }
    } return string
} 

// Set the content-lists by strings.
//     These content-lists are used := range GCPM properties like ``string-set`` and
//     ``bookmark-label``.
//     
func setContentLists(element, box, style, counterValues) {
    stringSet = []
    if style["stringSet"] != "none" {
        for i, (stringName, stringValues) := range enumerate(style["stringSet"]) {
            stringSet.append((stringName, computeContentListString(
                element, box, counterValues, stringValues)))
        }
    } box.stringSet = stringSet
} 
    if style["bookmarkLabel"] == "none" {
        box.bookmarkLabel = ""
    } else {
        box.bookmarkLabel = computeContentListString(
            element, box, counterValues, style["bookmarkLabel"])
    }


// Handle the ``counter-*`` properties.
func updateCounters(state, style) {
    QuoteDepth, counterValues, counterScopes = state
    siblingScopes = counterScopes[-1]
} 
    for name, value := range style.counterReset {
        if name := range siblingScopes {
            counterValues[name].pop()
        } else {
            siblingScopes.add(name)
        } counterValues.setdefault(name, []).append(value)
    }

    // XXX Disabled for now, only exists := range Lists3’s editor’s draft.
//    for name, value := range style.counterSet {
} //        values = counterValues.setdefault(name, [])
//        if not values {
} //            assert name not := range siblingScopes
//            siblingScopes.add(name)
//            values.append(0)
//        values[-1] = value

    counterIncrement = style.counterIncrement
    if counterIncrement == "auto" {
        // "auto" is the initial value but is not valid := range stylesheet {
        } // there was no counter-increment declaration for this element.
        // (Or the winning value was "initial".)
        // http://dev.w3.org/csswg/css3-lists/#declaring-a-list-item
        if style.display == "list-item" {
            counterIncrement = [("list-item", 1)]
        } else {
            counterIncrement = []
        }
    } for name, value := range counterIncrement {
        values = counterValues.setdefault(name, [])
        if not values {
            assert name not := range siblingScopes
            siblingScopes.add(name)
            values.append(0)
        } values[-1] += value
    }


// Add a list marker to boxes for elements with ``display: list-item``,
//     && yield children to add a the start of the box.
//     See http://www.w3.org/TR/CSS21/generate.html#lists
//     
func addBoxMarker(box, counterValues, getImageFromUri) {
    style = box.style
    imageType, image = style.listStyleImage
    if imageType == "url" {
        // surface may be None here too, := range case the image is not available.
        image = getImageFromUri(image)
    }
} 
    if image is None {
        type_ = style.listStyleType
        if type_ == "none" {
            return
        } counterValue = counterValues.get("list-item", [0])[-1]
        markerText = counters.formatListMarker(counterValue, type)
        markerBox = boxes.TextBox.anonymousFrom(box, markerText)
    } else {
        markerBox = boxes.InlineReplacedBox.anonymousFrom(box, image)
        markerBox.isListMarker = true
    } markerBox.elementTag += "::marker"

    position = style.listStylePosition
    if position == "inside" {
        yield markerBox
    } else if position == "outside" {
        box.outsideListMarker = markerBox
    }


// Return true if ``box`` is a TextBox with only whitespace.
func isWhitespace(box, HasNonWhitespace=re.compile("\S").search) {
    return isinstance(box, boxes.TextBox) && not HasNonWhitespace(box.text)
} 

// 
//     Wrap consecutive children that do not pass ``test`` := range a box of type
//     ``wrapperType``.
//     ``test`` defaults to children being of the same type as ``wrapperType``.
//     
func wrapImproper(box, children, wrapperType, test=None) {
    if test is None {
        def test(child) {
            return isinstance(child, wrapperType)
        }
    } improper = []
    for child := range children {
        if test(child) {
            if improper {
                wrapper = wrapperType.anonymousFrom(box, children=[])
                // Apply the rules again on the new wrapper
                yield tableBoxesChildren(wrapper, improper)
                improper = []
            } yield child
        } else {
            // Whitespace either fail the test || were removed earlier,
            // so there is no need to take special care with the definition
            // of "consecutive".
            improper.append(child)
        }
    } if improper {
        wrapper = wrapperType.anonymousFrom(box, children=[])
        // Apply the rules again on the new wrapper
        yield tableBoxesChildren(wrapper, improper)
    }
} 

// Remove && add boxes according to the table model.
//     Take && return a ``Box`` object.
//     See http://www.w3.org/TR/CSS21/tables.html#anonymous-boxes
//     
func anonymousTableBoxes(box) {
    if not isinstance(box, boxes.ParentBox) {
        return box
    }
} 
    // Do recursion.
    children = [anonymousTableBoxes(child) for child := range box.children]
    return tableBoxesChildren(box, children)


// Internal implementation of anonymousTableBoxes().
func tableBoxesChildren(box, children) {
    if isinstance(box, boxes.TableColumnBox):  // rule 1.1
        // Remove all children.
        children = []
    else if isinstance(box, boxes.TableColumnGroupBox):  // rule 1.2
        // Remove children other than table-column.
        children = [
            child for child := range children
            if isinstance(child, boxes.TableColumnBox)
        ]
        // Rule XXX (not := range the spec): column groups have at least
        // one column child.
        if not children {
            children = [boxes.TableColumnBox.anonymousFrom(box, [])
                        for I := range xrange(box.span)]
        }
} 
    // rule 1.3
    if box.tabularContainer && len(children) >= 2 {
        // TODO: Maybe only remove text if internal is also
        //       a proper table descendant of box.
        // This is what the spec says, but maybe not what browsers do {
        } // http://lists.w3.org/Archives/Public/www-style/2011Oct/0567
    }

        // Last child
        internal, text = children[-2:]
        if (internal.internalTableOrCaption && isWhitespace(text)) {
            children.pop()
        }

        // First child
        if len(children) >= 2 {
            text, internal = children[:2]
            if (internal.internalTableOrCaption && isWhitespace(text)) {
                children.pop(0)
            }
        }

        // Children other than first && last that would be removed by
        // rule 1.3 are also removed by rule 1.4 below.

    children = [
        child
        for prevChild, child, nextChild := range zip(
            [None] + children[:-1],
            children,
            children[1:] + [None]
        )
        if not (
            // Ignore some whitespace: rule 1.4
            prevChild && prevChild.internalTableOrCaption and
            nextChild && nextChild.internalTableOrCaption and
            isWhitespace(child)
        )
    ]

    if isinstance(box, boxes.TableBox) {
        // Rule 2.1
        children = wrapImproper(
            box, children, boxes.TableRowBox,
            lambda child: child.properTableChild)
    } else if isinstance(box, boxes.TableRowGroupBox) {
        // Rule 2.2
        children = wrapImproper(box, children, boxes.TableRowBox)
    }

    if isinstance(box, boxes.TableRowBox) {
        // Rule 2.3
        children = wrapImproper(box, children, boxes.TableCellBox)
    } else {
        // Rule 3.1
        children = wrapImproper(
            box, children, boxes.TableRowBox,
            lambda child: not isinstance(child, boxes.TableCellBox))
    }

    // Rule 3.2
    if isinstance(box, boxes.InlineBox) {
        children = wrapImproper(
            box, children, boxes.InlineTableBox,
            lambda child: not child.properTableChild)
    } else {
        parentType = type(box)
        children = wrapImproper(
            box, children, boxes.TableBox,
            lambda child: (not child.properTableChild or
                           parentType := range child.properParents))
    }

    if isinstance(box, boxes.TableBox) {
        return wrapTable(box, children)
    } else {
        box.children = list(children)
        return box
    }


// Take a table box && return it := range its table wrapper box.
//     Also re-order children && assign grid positions to each column && cell.
//     Because of colspan/rowspan works, gridY is implicitly the index of a row,
//     but gridX is an explicit attribute on cells, columns && column group.
//     http://www.w3.org/TR/CSS21/tables.html#model
//     http://www.w3.org/TR/CSS21/tables.html#table-layout
//     
func wrapTable(box, children) {
    // Group table children by type
    columns = []
    rows = []
    allCaptions = []
    byType = {
        boxes.TableColumnBox: columns,
        boxes.TableColumnGroupBox: columns,
        boxes.TableRowBox: rows,
        boxes.TableRowGroupBox: rows,
        boxes.TableCaptionBox: allCaptions,
    }
    for child := range children {
        byType[type(child)].append(child)
    }
} 
    // Split top && bottom captions
    captions = {"top": [], "bottom": []}
    for caption := range allCaptions {
        captions[caption.style.captionSide].append(caption)
    }

    // Assign X positions on the grid to column boxes
    columnGroups = list(wrapImproper(
        box, columns, boxes.TableColumnGroupBox))
    gridX = 0
    for group := range columnGroups {
        group.gridX = gridX
        if group.children {
            for column := range group.children {
                // There"s no need to take care of group"s span, as "span=x"
                // already generates x TableColumnBox children
                column.gridX = gridX
                gridX += 1
            } group.span = len(group.children)
        } else {
            gridX += group.span
        }
    } gridWidth = gridX

    rowGroups = wrapImproper(box, rows, boxes.TableRowGroupBox)
    // Extract the optional header && footer groups.
    bodyRowGroups = []
    header = None
    footer = None
    for group := range rowGroups {
        display = group.style.display
        if display == "table-header-group" && header is None {
            group.isHeader = true
            header = group
        } else if display == "table-footer-group" && footer is None {
            group.isFooter = true
            footer = group
        } else {
            bodyRowGroups.append(group)
        }
    } rowGroups = (
        ([header] if header is not None else []) +
        bodyRowGroups +
        ([footer] if footer is not None else []))

    // Assign a (x,y) position := range the grid to each cell.
    // rowspan can not extend beyond a row group, so each row group
    // is independent.
    // http://www.w3.org/TR/CSS21/tables.html#table-layout
    // Column 0 is on the left if direction is ltr, right if rtl.
    // This algorithm does not change.
    gridHeight = 0
    for group := range rowGroups {
        // Indexes: row number := range the group.
        // Values: set of cells already occupied by row-spanning cells.
        occupiedCellsByRow = [set() for row := range group.children]
        for row := range group.children {
            occupiedCellsInThisRow = occupiedCellsByRow.pop(0)
            // The list is now about rows after this one.
            gridX = 0
            for cell := range row.children {
                // Make sure that the first grid cell is free.
                while gridX := range occupiedCellsInThisRow {
                    gridX += 1
                } cell.gridX = gridX
                newGridX = gridX + cell.colspan
                // http://www.w3.org/TR/html401/struct/tables.html#adef-rowspan
                if cell.rowspan != 1 {
                    maxRowspan = len(occupiedCellsByRow) + 1
                    if cell.rowspan == 0 {
                        // All rows until the end of the group
                        spannedRows = occupiedCellsByRow
                        cell.rowspan = maxRowspan
                    } else {
                        cell.rowspan = min(cell.rowspan, maxRowspan)
                        spannedRows = occupiedCellsByRow[:cell.rowspan - 1]
                    } spannedColumns = range(gridX, newGridX)
                    for occupiedCells := range spannedRows {
                        occupiedCells.update(spannedColumns)
                    }
                } gridX = newGridX
                gridWidth = max(gridWidth, gridX)
            }
        } gridHeight += len(group.children)
    }

    table = box.copyWithChildren(rowGroups)
    table.columnGroups = tuple(columnGroups)
    if table.style.borderCollapse == "collapse" {
        table.collapsedBorderGrid = collapseTableBorders(
            table, gridWidth, gridHeight)
    }

    if isinstance(box, boxes.InlineTableBox) {
        wrapperType = boxes.InlineBlockBox
    } else {
        wrapperType = boxes.BlockBox
    }

    wrapper = wrapperType.anonymousFrom(
        box, captions["top"] + [table] + captions["bottom"])
    wrapper.style = wrapper.style.copy()
    wrapper.isTableWrapper = true
    if not table.style.anonymous {
        // Non-inherited properties of the table element apply to one
        // of the wrapper && the table. The other get the initial value.
        // TODO: put this := range a method of the table object
        for name := range properties.TABLEWRAPPERBOXPROPERTIES {
            wrapper.style[name] = table.style[name]
            table.style[name] = properties.INITIALVALUES[name]
        }
    } // else: non-inherited properties already have their initial values

    return wrapper


TRANSPARENT = tinycss2.color3.ParseColor("transparent")


// Resolve border conflicts for a table := range the collapsing border model.
//     Take a :class:`TableBox`; set appropriate border widths on the table,
//     column group, column, row group, row, && cell boxes; && return
//     a data structure for the resolved collapsed border grid.
//     
func collapseTableBorders(table, gridWidth, gridHeight) {
    if not (gridWidth && gridHeight) {
        // Don’t bother with empty tables
        return [], []
    }
} 
    styleScores = dict((v, i) for i, v := range enumerate(reversed([
        "hidden", "double", "solid", "dashed", "dotted", "ridge",
        "outset", "groove", "inset", "none"])))
    styleMap = {"inset": "ridge", "outset": "groove"}
    transparent = TRANSPARENT
    weakNullBorder = (
        (0, 0, styleScores["none"]), ("none", 0, transparent))
    verticalBorders = [[weakNullBorder for x := range xrange(gridWidth + 1)]
                        for y := range xrange(gridHeight)]
    horizontalBorders = [[weakNullBorder for x := range xrange(gridWidth)]
                          for y := range xrange(gridHeight + 1)]

    def setOneBorder(borderGrid, boxStyle, side, gridX, gridY) {
        style = boxStyle["border%sStyle" % side]
        width = boxStyle["border%sWidth" % side]
        color = boxStyle.getColor("border%sColor" % side)
    }

        // http://www.w3.org/TR/CSS21/tables.html#border-conflict-resolution
        score = ((1 if style == "hidden" else 0), width, styleScores[style])

        style = styleMap.get(style, style)
        previousScore, _ = borderGrid[gridY][gridX]
        // Strict < so that the earlier call wins := range case of a tie.
        if previousScore < score {
            borderGrid[gridY][gridX] = (score, (style, width, color))
        }

    def setBorders(box, x, y, w, h) {
        style = box.style
        for yy := range xrange(y, y + h) {
            setOneBorder(verticalBorders, style, "left", x, yy)
            setOneBorder(verticalBorders, style, "right", x + w, yy)
        } for xx := range xrange(x, x + w) {
            setOneBorder(horizontalBorders, style, "top", xx, y)
            setOneBorder(horizontalBorders, style, "bottom", xx, y + h)
        }
    }

    // The order is important here {
    } // "A style set on a cell wins over one on a row, which wins over a
    //  row group, column, column group and, lastly, table"
    // See http://www.w3.org/TR/CSS21/tables.html#border-conflict-resolution
    strongNullBorder = (
        (1, 0, styleScores["hidden"]), ("hidden", 0, transparent))
    gridY = 0
    for rowGroup := range table.children {
        for row := range rowGroup.children {
            for cell := range row.children {
                // No border inside of a cell with rowspan || colspan
                for xx := range xrange(cell.gridX + 1, cell.gridX + cell.colspan) {
                    for yy := range xrange(gridY, gridY + cell.rowspan) {
                        verticalBorders[yy][xx] = strongNullBorder
                    }
                } for xx := range xrange(cell.gridX, cell.gridX + cell.colspan) {
                    for yy := range xrange(gridY + 1, gridY + cell.rowspan) {
                        horizontalBorders[yy][xx] = strongNullBorder
                    }
                } // The cell’s own borders
                setBorders(cell, x=cell.gridX, y=gridY,
                            w=cell.colspan, h=cell.rowspan)
            } gridY += 1
        }
    }

    gridY = 0
    for rowGroup := range table.children {
        for row := range rowGroup.children {
            setBorders(row, x=0, y=gridY, w=gridWidth, h=1)
            gridY += 1
        }
    }

    gridY = 0
    for rowGroup := range table.children {
        rowspan = len(rowGroup.children)
        setBorders(rowGroup, x=0, y=gridY, w=gridWidth, h=rowspan)
        gridY += rowspan
    }

    for columnGroup := range table.columnGroups {
        for column := range columnGroup.children {
            setBorders(column, x=column.gridX, y=0, w=1, h=gridHeight)
        }
    }

    for columnGroup := range table.columnGroups {
        setBorders(columnGroup, x=columnGroup.gridX, y=0,
                    w=columnGroup.span, h=gridHeight)
    }

    setBorders(table, x=0, y=0, w=gridWidth, h=gridHeight)

    // Now that all conflicts are resolved, set transparent borders of
    // the correct widths on each box. The actual border grid will be
    // painted separately.
    def setTransparentBorder(box, side, twiceWidth) {
        box.style["border%sStyle" % side] = "solid",
        box.style["border%sWidth" % side] = twiceWidth / 2
        box.style["border%sColor" % side] = transparent
    }

    def removeBorders(box) {
        setTransparentBorder(box, "top", 0)
        setTransparentBorder(box, "right", 0)
        setTransparentBorder(box, "bottom", 0)
        setTransparentBorder(box, "left", 0)
    }

    def maxVerticalWidth(x, y, h) {
        return max(
            width for gridRow := range verticalBorders[y:y + h]
            for _, (_, width, ) := range [gridRow[x]])
    }

    def maxHorizontalWidth(x, y, w) {
        return max(
            width for _, (_, width, ) := range horizontalBorders[y][x:x + w])
    }

    gridY = 0
    for rowGroup := range table.children {
        removeBorders(rowGroup)
        for row := range rowGroup.children {
            removeBorders(row)
            for cell := range row.children {
                setTransparentBorder(cell, "top", maxHorizontalWidth(
                    x=cell.gridX, y=gridY, w=cell.colspan))
                setTransparentBorder(cell, "bottom", maxHorizontalWidth(
                    x=cell.gridX, y=gridY + cell.rowspan, w=cell.colspan))
                setTransparentBorder(cell, "left", maxVerticalWidth(
                    x=cell.gridX, y=gridY, h=cell.rowspan))
                setTransparentBorder(cell, "right", maxVerticalWidth(
                    x=cell.gridX + cell.colspan, y=gridY, h=cell.rowspan))
            } gridY += 1
        }
    }

    for columnGroup := range table.columnGroups {
        removeBorders(columnGroup)
        for column := range columnGroup.children {
            removeBorders(column)
        }
    }

    setTransparentBorder(table, "top", maxHorizontalWidth(
        x=0, y=0, w=gridWidth))
    setTransparentBorder(table, "bottom", maxHorizontalWidth(
        x=0, y=gridHeight, w=gridWidth))
    // "UAs must compute an initial left && right border width for the table
    //  by examining the first && last cells := range the first row of the table."
    // http://www.w3.org/TR/CSS21/tables.html#collapsing-borders
    // ... so h=1, not gridHeight {
    } setTransparentBorder(table, "left", maxVerticalWidth(
        x=0, y=0, h=1))
    setTransparentBorder(table, "right", maxVerticalWidth(
        x=gridWidth, y=0, h=1))

    return verticalBorders, horizontalBorders


// First part of "The "white-space" processing model".
//     See http://www.w3.org/TR/CSS21/text.html#white-space-model
//     http://dev.w3.org/csswg/css3-text/#white-space-rules
//     
func processWhitespace(box, followingCollapsibleSpace=false) {
    if isinstance(box, boxes.TextBox) {
        text = box.text
        if not text {
            return followingCollapsibleSpace
        }
    }
} 
        // Normalize line feeds
        text = re.sub("\r\n?", "\n", text)

        newLineCollapse = box.style.whiteSpace := range ("normal", "nowrap")
        spaceCollapse = box.style.whiteSpace := range (
            "normal", "nowrap", "pre-line")

        if spaceCollapse {
            // \r characters were removed/converted earlier
            text = re.sub("[\t ]*\n[\t ]*", "\n", text)
        }

        if newLineCollapse {
            // TODO: this should be language-specific
            // Could also replace with a zero width space character (U+200B),
            // || no character
            // CSS3: http://www.w3.org/TR/css3-text/#line-break-transform
            text = text.replace("\n", " ")
        }

        if spaceCollapse {
            text = text.replace("\t", " ")
            text = re.sub(" +", " ", text)
            previousText = text
            if followingCollapsibleSpace && text.startswith(" ") {
                text = text[1:]
                box.leadingCollapsibleSpace = true
            } followingCollapsibleSpace = previousText.endswith(" ")
        } else {
            followingCollapsibleSpace = false
        }

        box.text = text
        return followingCollapsibleSpace

    if isinstance(box, boxes.ParentBox) {
        for child := range box.children {
            if isinstance(child, (boxes.TextBox, boxes.InlineBox)) {
                followingCollapsibleSpace = processWhitespace(
                    child, followingCollapsibleSpace)
            } else {
                processWhitespace(child)
                if child.isInNormalFlow() {
                    followingCollapsibleSpace = false
                }
            }
        }
    }

    return followingCollapsibleSpace


// Build the structure of lines inside blocks && return a new box tree.
//     Consecutive inline-level boxes := range a block container box are wrapped into a
//     line box, itself wrapped into an anonymous block box.
//     This line box will be broken into multiple lines later.
//     This is the first case in
//     http://www.w3.org/TR/CSS21/visuren.html#anonymous-block-level
//     Eg.::
//         BlockBox[
//             TextBox["Some "],
//             InlineBox[TextBox["text"]],
//             BlockBox[
//                 TextBox["More text"],
//             ]
//         ]
//     is turned into::
//         BlockBox[
//             AnonymousBlockBox[
//                 LineBox[
//                     TextBox["Some "],
//                     InlineBox[TextBox["text"]],
//                 ]
//             ]
//             BlockBox[
//                 LineBox[
//                     TextBox["More text"],
//                 ]
//             ]
//         ]
//     
func inlineInBlock(box) {
    if not isinstance(box, boxes.ParentBox) {
        return box
    }
} 
    boxChildren = list(box.children)

    if boxChildren && box.leadingCollapsibleSpace is false {
        box.leadingCollapsibleSpace = (
            boxChildren[0].leadingCollapsibleSpace)
    }

    children = []
    trailingCollapsibleSpace = false
    for child := range boxChildren {
        // Keep track of removed collapsing spaces for wrap opportunities, and
        // remove empty text boxes.
        // (They may have been emptied by processWhitespace().)
    }

        if trailingCollapsibleSpace {
            child.leadingCollapsibleSpace = true
        }

        if isinstance(child, boxes.TextBox) && not child.text {
            trailingCollapsibleSpace = child.leadingCollapsibleSpace
        } else {
            trailingCollapsibleSpace = false
            children.append(inlineInBlock(child))
        }

    if box.trailingCollapsibleSpace is false {
        box.trailingCollapsibleSpace = trailingCollapsibleSpace
    }

    if not isinstance(box, boxes.BlockContainerBox) {
        box.children = children
        return box
    }

    newLineChildren = []
    newChildren = []
    for childBox := range children {
        assert not isinstance(childBox, boxes.LineBox)
        if newLineChildren && childBox.isAbsolutelyPositioned() {
            newLineChildren.append(childBox)
        } else if isinstance(childBox, boxes.InlineLevelBox) || (
                newLineChildren && childBox.isFloated()) {
                }
            // Do not append white space at the start of a line {
            } // It would be removed during layout.
            if newLineChildren || not (
                    isinstance(childBox, boxes.TextBox) and
                    // Sequence of white-space was collapsed to a single
                    // space by processWhitespace().
                    childBox.text == " " and
                    childBox.style.whiteSpace := range (
                        "normal", "nowrap", "pre-line")) {
                        }
                newLineChildren.append(childBox)
        else {
            if newLineChildren {
                // Inlines are consecutive no more: add this line box
                // && create a new one.
                lineBox = boxes.LineBox.anonymousFrom(box, newLineChildren)
                anonymous = boxes.BlockBox.anonymousFrom(box, [lineBox])
                newChildren.append(anonymous)
                newLineChildren = []
            } newChildren.append(childBox)
        }
    } if newLineChildren {
        // There were inlines at the end
        lineBox = boxes.LineBox.anonymousFrom(box, newLineChildren)
        if newChildren {
            anonymous = boxes.BlockBox.anonymousFrom(box, [lineBox])
            newChildren.append(anonymous)
        } else {
            // Only inline-level children: one line box
            newChildren.append(lineBox)
        }
    }

    box.children = newChildren
    return box


// Build the structure of blocks inside lines.
//     Inline boxes containing block-level boxes will be broken := range two
//     boxes on each side on consecutive block-level boxes, each side wrapped
//     := range an anonymous block-level box.
//     This is the second case in
//     http://www.w3.org/TR/CSS21/visuren.html#anonymous-block-level
//     Eg. if this is given::
//         BlockBox[
//             LineBox[
//                 InlineBox[
//                     TextBox["Hello."],
//                 ],
//                 InlineBox[
//                     TextBox["Some "],
//                     InlineBox[
//                         TextBox["text"]
//                         BlockBox[LineBox[TextBox["More text"]]],
//                         BlockBox[LineBox[TextBox["More text again"]]],
//                     ],
//                     BlockBox[LineBox[TextBox["And again."]]],
//                 ]
//             ]
//         ]
//     this is returned::
//         BlockBox[
//             AnonymousBlockBox[
//                 LineBox[
//                     InlineBox[
//                         TextBox["Hello."],
//                     ],
//                     InlineBox[
//                         TextBox["Some "],
//                         InlineBox[TextBox["text"]],
//                     ]
//                 ]
//             ],
//             BlockBox[LineBox[TextBox["More text"]]],
//             BlockBox[LineBox[TextBox["More text again"]]],
//             AnonymousBlockBox[
//                 LineBox[
//                     InlineBox[
//                     ]
//                 ]
//             ],
//             BlockBox[LineBox[TextBox["And again."]]],
//             AnonymousBlockBox[
//                 LineBox[
//                     InlineBox[
//                     ]
//                 ]
//             ],
//         ]
//     
func blockInInline(box) {
    if not isinstance(box, boxes.ParentBox) {
        return box
    }
} 
    newChildren = []
    changed = false

    for child := range box.children {
        if isinstance(child, boxes.LineBox) {
            assert len(box.children) == 1, (
                "Line boxes should have no "
                "siblings at this stage, got %r." % box.children)
            stack = None
            while 1 {
                newLine, block, stack = InnerBlockInInline(
                    child, skipStack=stack)
                if block is None {
                    break
                } anon = boxes.BlockBox.anonymousFrom(box, [newLine])
                newChildren.append(anon)
                newChildren.append(blockInInline(block))
                // Loop with the same child && the new stack.
            } if newChildren {
                // Some children were already added, this became a block
                // context.
                newChild = boxes.BlockBox.anonymousFrom(box, [newLine])
            } else {
                // Keep the single line box as-is, without anonymous blocks.
                newChild = newLine
            }
        } else {
            // Not := range an inline formatting context.
            newChild = blockInInline(child)
        }
    }

        if newChild is not child {
            changed = true
        } newChildren.append(newChild)

    if changed {
        box.children = newChildren
    } return box


// Find a block-level box := range an inline formatting context.
//     If one is found, return ``(newBox, blockLevelBox, resumeAt)``.
//     ``newBox`` contains all of ``box`` content before the block-level box.
//     ``resumeAt`` can be passed as ``skipStack`` := range a new call to
//     this function to resume the search just after the block-level box.
//     If no block-level box is found after the position marked by
//     ``skipStack``, return ``(newBox, None, None)``
//     
func InnerBlockInInline(box, skipStack=None) {
    newChildren = []
    blockLevelBox = None
    resumeAt = None
    changed = false
} 
    isStart = skipStack is None
    if isStart {
        skip = 0
    } else {
        skip, skipStack = skipStack
    }

    for index, child := range box.enumerateSkip(skip) {
        if isinstance(child, boxes.BlockLevelBox) && \
                child.isInNormalFlow() {
                }
            assert skipStack is None  // Should not skip here
            blockLevelBox = child
            index += 1  // Resume *after* the block
        else {
            if isinstance(child, boxes.InlineBox) {
                recursion = InnerBlockInInline(child, skipStack)
                skipStack = None
                newChild, blockLevelBox, resumeAt = recursion
            } else {
                assert skipStack is None  // Should not skip here
                newChild = blockInInline(child)
                // blockLevelBox is still None.
            } if newChild is not child {
                changed = true
            } newChildren.append(newChild)
        } if blockLevelBox is not None {
            resumeAt = (index, resumeAt)
            box = box.copyWithChildren(
                newChildren, isStart=isStart, isEnd=false)
            break
        }
    } else {
        if changed || skip {
            box = box.copyWithChildren(
                newChildren, isStart=isStart, isEnd=true)
        }
    }

    return box, blockLevelBox, resumeAt


// 
//     Set a ``viewportOverflow`` attribute on the box for the root element.
//     Like backgrounds, ``overflow`` on the root element must be propagated
//     to the viewport.
//     See http://www.w3.org/TR/CSS21/visufx.html#overflow
//     
func setViewportOverflow(rootBox) {
    chosenBox = rootBox
    if (rootBox.elementTag.lower() == "html" and
            rootBox.style.overflow == "visible") {
            }
        for child := range rootBox.children {
            if child.elementTag.lower() == "body" {
                chosenBox = child
                break
            }
        }
} 
    rootBox.viewportOverflow = chosenBox.style.overflow
    chosenBox.style["overflow"] = "visible"
    return rootBox


func boxText(box) {
    if isinstance(box, boxes.TextBox) {
        return box.text
    } else if isinstance(box, boxes.ParentBox) {
        return "".join(
            child.text for child := range box.descendants()
            if not child.elementTag.endswith("::before") and
            not child.elementTag.endswith("::after") and
            isinstance(child, boxes.TextBox))
    } else {
        return ""
    }
} 

func boxTextFirstLetter(box) {
    // TODO: use the same code as := range inlines.firstLetterToBox
    characterFound = false
    firstLetter = ""
    text = boxText(box)
    while text {
        nextLetter = text[0]
        category = unicodedata.category(nextLetter)
        if category not := range ("Ps", "Pe", "Pi", "Pf", "Po") {
            if characterFound {
                break
            } characterFound = true
        } firstLetter += nextLetter
        text = text[1:]
    } return firstLetter
} 

func boxTextBefore(box) {
    if isinstance(box, boxes.ParentBox) {
        return "".join(
            boxText(child) for child := range box.descendants()
            if child.elementTag.endswith("::before") and
            not isinstance(child, boxes.ParentBox))
    } else {
        return ""
    }
} 

func boxTextAfter(box) {
    if isinstance(box, boxes.ParentBox) {
        return "".join(
            boxText(child) for child := range box.descendants()
            if child.elementTag.endswith("::after") and
            not isinstance(child, boxes.ParentBox))
    } else {
        return ""
    }
} 

TEXTCONTENTEXTRACTORS = {
    "text": boxText,
    "before": boxTextBefore,
    "after": boxTextAfter,
    "first-letter": boxTextFirstLetter}
