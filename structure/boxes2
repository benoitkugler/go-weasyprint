package structure

# coding: utf-8
"""
weasyprint.formattingStructure.boxes
-------------------------------------

Classes for all types of boxes in the CSS formatting structure / box model.

See http://www.w3.org/TR/CSS21/visuren.html

Names are the same as in CSS 2.1 with the exception of ``TextBox``. In
WeasyPrint, any text is in a ``TextBox``. What CSS calls anonymous
inline boxes are text boxes but not all text boxes are anonymous
inline boxes.

See http://www.w3.org/TR/CSS21/visuren.html#anonymous

Abstract classes, should not be instantiated:

* Box
* BlockLevelBox
* InlineLevelBox
* BlockContainerBox
* ReplacedBox
* ParentBox
* AtomicInlineLevelBox

Concrete classes:

* PageBox
* BlockBox
* InlineBox
* InlineBlockBox
* BlockReplacedBox
* InlineReplacedBox
* TextBox
* LineBox
* Various table-related Box subclasses

All concrete box classes whose name contains "Inline" or "Block" have
one of the following "outside" behavior:

* Block-level (inherits from :class:`BlockLevelBox`)
* Inline-level (inherits from :class:`InlineLevelBox`)

and one of the following "inside" behavior:

* Block container (inherits from :class:`BlockContainerBox`)
* Inline content (InlineBox and :class:`TextBox`)
* Replaced content (inherits from :class:`ReplacedBox`)

... with various combinasions of both.

See respective docstrings for details.

:copyright: Copyright 2011-2014 Simon Sapin and contributors, see AUTHORS.
:license: BSD, see LICENSE for details.

"""

from _Future_ import division, unicodeLiterals

import itertools

from ..compat import unichr, xrange
from ..css.properties import Dimension

# The *Box classes have many attributes and methods, but that's the way it is
# pylint: disable=R0904,R0902


class Box(object):
"""Abstract base class for all boxes."""
# Definitions for the rules generating anonymous table boxes
# http://www.w3.org/TR/CSS21/tables.html#anonymous-boxes
properTableChild = False
internalTableOrCaption = False
tabularContainer = False

# Keep track of removed collapsing spaces for wrap opportunities.
leadingCollapsibleSpace = False
trailingCollapsibleSpace = False

# Default, may be overriden on instances.
isTableWrapper = False
isForRootElement = False
isColumn = False
transformationMatrix = None
bookmarkLabel = None
stringSet = None

# Default, overriden on some subclasses
def allChildren(self):
return ()

def _Init_(self, elementTag, style):
self.elementTag = elementTag
self.style = style

def _Repr_(self):
return '<%s %s>' % (type(self)._Name_, self.elementTag)

@classmethod
def anonymousFrom(cls, parent, *args, **kwargs):
"""Return an anonymous box that inherits from ``parent``."""
return cls(
parent.elementTag, parent.style.inheritFrom(), *args, **kwargs)

def copy(self):
"""Return shallow copy of the box."""
cls = type(self)
# Create a new instance without calling _Init_: initializing
# styles may be kinda expensive, no need to do it again.
newBox = cls._New_(cls)
# Copy attributes
newBox._Dict_.update(self._Dict_)
newBox.style = self.style
return newBox

def translate(self, dx=0, dy=0, ignoreFloats=False):
"""Change the box’s position.

Also update the children’s positions accordingly.

"""
# Overridden in ParentBox to also translate children, if any.
if dx == 0 and dy == 0:
return
self.positionX += dx
self.positionY += dy
for child in self.allChildren():
if not (ignoreFloats and child.isFloated()):
child.translate(dx, dy, ignoreFloats)

# Heights and widths

def paddingWidth(self):
"""Width of the padding box."""
return self.width + self.paddingLeft + self.paddingRight

def paddingHeight(self):
"""Height of the padding box."""
return self.height + self.paddingTop + self.paddingBottom

def borderWidth(self):
"""Width of the border box."""
return self.paddingWidth() + self.borderLeftWidth + \
self.borderRightWidth

def borderHeight(self):
"""Height of the border box."""
return self.paddingHeight() + self.borderTopWidth + \
self.borderBottomWidth

def marginWidth(self):
"""Width of the margin box (aka. outer box)."""
return self.borderWidth() + self.marginLeft + self.marginRight

def marginHeight(self):
"""Height of the margin box (aka. outer box)."""
return self.borderHeight() + self.marginTop + self.marginBottom

# Corners positions

def contentBoxX(self):
"""Absolute horizontal position of the content box."""
return self.positionX + self.marginLeft + self.paddingLeft + \
self.borderLeftWidth

def contentBoxY(self):
"""Absolute vertical position of the content box."""
return self.positionY + self.marginTop + self.paddingTop + \
self.borderTopWidth

def paddingBoxX(self):
"""Absolute horizontal position of the padding box."""
return self.positionX + self.marginLeft + self.borderLeftWidth

def paddingBoxY(self):
"""Absolute vertical position of the padding box."""
return self.positionY + self.marginTop + self.borderTopWidth

def borderBoxX(self):
"""Absolute horizontal position of the border box."""
return self.positionX + self.marginLeft

def borderBoxY(self):
"""Absolute vertical position of the border box."""
return self.positionY + self.marginTop

def hitArea(self):
"""Return the (x, y, w, h) rectangle where the box is clickable."""
# "Border area. That's the area that hit-testing is done on."
# http://lists.w3.org/Archives/Public/www-style/2012Jun/0318.html
# TODO: manage the border radii, use outerBorderRadii instead
return (self.borderBoxX(), self.borderBoxY(),
self.borderWidth(), self.borderHeight())

def roundedBox(self, bt, br, bb, bl):
"""Position, size and radii of a box inside the outer border box.

bt, br, bb, and bl are distances from the outer border box,
defining a rectangle to be rounded.

"""
tlrx, tlry = self.borderTopLeftRadius
trrx, trry = self.borderTopRightRadius
brrx, brry = self.borderBottomRightRadius
blrx, blry = self.borderBottomLeftRadius

tlrx = max(0, tlrx - bl)
tlry = max(0, tlry - bt)
trrx = max(0, trrx - br)
trry = max(0, trry - bt)
brrx = max(0, brrx - br)
brry = max(0, brry - bb)
blrx = max(0, blrx - bl)
blry = max(0, blry - bb)

x = self.borderBoxX() + bl
y = self.borderBoxY() + bt
width = self.borderWidth() - bl - br
height = self.borderHeight() - bt - bb

# Fix overlapping curves
# See http://www.w3.org/TR/css3-background/#corner-overlap
ratio = min([1] + [
extent / sumRadii
for extent, sumRadii in [
(width, tlrx + trrx),
(width, blrx + brrx),
(height, tlry + blry),
(height, trry + brry),
]
if sumRadii > 0
])
return (
x, y, width, height,
(tlrx * ratio, tlry * ratio),
(trrx * ratio, trry * ratio),
(brrx * ratio, brry * ratio),
(blrx * ratio, blry * ratio))

def roundedBoxRatio(self, ratio):
return self.roundedBox(
self.borderTopWidth * ratio,
self.borderRightWidth * ratio,
self.borderBottomWidth * ratio,
self.borderLeftWidth * ratio)

def roundedPaddingBox(self):
"""Return the position, size and radii of the rounded padding box."""
return self.roundedBox(
self.borderTopWidth,
self.borderRightWidth,
self.borderBottomWidth,
self.borderLeftWidth)

def roundedBorderBox(self):
"""Return the position, size and radii of the rounded border box."""
return self.roundedBox(0, 0, 0, 0)

def roundedContentBox(self):
"""Return the position, size and radii of the rounded content box."""
return self.roundedBox(
self.borderTopWidth + self.paddingTop,
self.borderRightWidth + self.paddingRight,
self.borderBottomWidth + self.paddingBottom,
self.borderLeftWidth + self.paddingLeft)

# Positioning schemes

def isFloated(self):
"""Return whether this box is floated."""
return self.style.float != 'none'

def isAbsolutelyPositioned(self):
"""Return whether this box is in the absolute positioning scheme."""
return self.style.position in ('absolute', 'fixed')

def isInNormalFlow(self):
"""Return whether this box is in normal flow."""
return not (self.isFloated() or self.isAbsolutelyPositioned())

# Start and end page values for named pages

def pageValues(self):
"""Return start and end page values."""
return (self.style['page'], self.style['page'])


class ParentBox(Box):
"""A box that has children."""
def _Init_(self, elementTag, style, children):
super(ParentBox, self)._Init_(elementTag, style)
self.children = tuple(children)

def allChildren(self):
return self.children

def enumerateSkip(self, skipNum=0):
"""Yield ``(child, childIndex)`` tuples for each child.

``skipNum`` children are skipped before iterating over them.

"""
for index in xrange(skipNum, len(self.children)):
yield index, self.children[index]

def ResetSpacing(self, side):
"""Set to 0 the margin, padding and border of ``side``."""
self.style['margin%s' % side] = Dimension(0, 'px')
self.style['padding%s' % side] = Dimension(0, 'px')
self.style['border%sWidth' % side] = 0
setattr(self, 'margin%s' % side, 0)
setattr(self, 'padding%s' % side, 0)
setattr(self, 'border%sWidth' % side, 0)

def RemoveDecoration(self, start, end):
if start or end:
self.style = self.style.copy()
if start:
self.ResetSpacing('top')
if end:
self.ResetSpacing('bottom')

def copyWithChildren(self, newChildren, isStart=True, isEnd=True):
"""Create a new equivalent box with given ``newChildren``."""
newBox = self.copy()
newBox.children = tuple(newChildren)
if not isStart:
newBox.outsideListMarker = None
newBox.RemoveDecoration(not isStart, not isEnd)
return newBox

def descendants(self):
"""A flat generator for a box, its children and descendants."""
yield self
for child in self.children:
if hasattr(child, 'descendants'):
for grandChild in child.descendants():
yield grandChild
else:
yield child

def getWrappedTable(self):
"""Get the table wrapped by the box."""
if self.isTableWrapper:
for child in self.children:
if isinstance(child, TableBox):
return child
else:  # pragma: no cover
raise ValueError('Table wrapper without a table')

def pageValues(self):
startValue, endValue = super(ParentBox, self).pageValues()
if self.children:
startBox, endBox = self.children[0], self.children[-1]
startValue = startBox.pageValues()[0] or startValue
endValue = endBox.pageValues()[1] or endValue
return startValue, endValue


class BlockLevelBox(Box):
"""A box that participates in an block formatting context.

An element with a ``display`` value of ``block``, ``list-item`` or
``table`` generates a block-level box.

"""
clearance = None


class BlockContainerBox(ParentBox):
"""A box that contains only block-level boxes or only line boxes.

A box that either contains only block-level boxes or establishes an inline
formatting context and thus contains only line boxes.

A non-replaced element with a ``display`` value of ``block``,
``list-item``, ``inline-block`` or 'table-cell' generates a block container
box.

"""


class BlockBox(BlockContainerBox, BlockLevelBox):
"""A block-level box that is also a block container.

A non-replaced element with a ``display`` value of ``block``, ``list-item``
generates a block box.

"""
# TODO: remove this when outside list marker are absolute children
def allChildren(self):
marker = getattr(self, 'outsideListMarker', None)
return (itertools.chain(self.children, [marker])
if marker else self.children)


class LineBox(ParentBox):
"""A box that represents a line in an inline formatting context.

Can only contain inline-level boxes.

In early stages of building the box tree a single line box contains many
consecutive inline boxes. Later, during layout phase, each line boxes will
be split into multiple line boxes, one for each actual line.

"""
def _Init_(self, elementTag, style, children):
assert style.anonymous
super(LineBox, self)._Init_(elementTag, style, children)


class InlineLevelBox(Box):
"""A box that participates in an inline formatting context.

An inline-level box that is not an inline box is said to be "atomic". Such
boxes are inline blocks, replaced elements and inline tables.

An element with a ``display`` value of ``inline``, ``inline-table``, or
``inline-block`` generates an inline-level box.

"""
def RemoveDecoration(self, start, end):
if start or end:
self.style = self.style.copy()
ltr = self.style.direction == 'ltr'
        if start:
self.ResetSpacing('left' if ltr else 'right')
if end:
self.ResetSpacing('right' if ltr else 'left')


class InlineBox(InlineLevelBox, ParentBox):
"""An inline box with inline children.

A box that participates in an inline formatting context and whose content
also participates in that inline formatting context.

A non-replaced element with a ``display`` value of ``inline`` generates an
inline box.

"""
def hitArea(self):
"""Return the (x, y, w, h) rectangle where the box is clickable."""
# Use line-height (marginHeight) rather than borderHeight
return (self.borderBoxX(), self.positionY,
self.borderWidth(), self.marginHeight())


class TextBox(InlineLevelBox):
"""A box that contains only text and has no box children.

Any text in the document ends up in a text box. What CSS calls "anonymous
inline boxes" are also text boxes.

"""
justificationSpacing = 0

# http://stackoverflow.com/questions/16317534/
asciiToWide = dict((i, unichr(i + 0xfee0)) for i in range(0x21, 0x7f))
asciiToWide.update({0x20: '\u3000', 0x2D: '\u2212'})

def _Init_(self, elementTag, style, text):
assert style.anonymous
assert text
super(TextBox, self)._Init_(elementTag, style)
textTransform = style.textTransform
if textTransform != 'none':
text = {
'uppercase': lambda t: t.upper(),
'lowercase': lambda t: t.lower(),
# Python’s unicode.captitalize is not the same.
'capitalize': lambda t: t.title(),
'full-width': lambda t: t.translate(self.asciiToWide),
}[textTransform](text)
if style.hyphens == 'none':
text = text.replace('\u00AD', '')  # U+00AD SOFT HYPHEN (SHY)
self.text = text

def copyWithText(self, text):
"""Return a new TextBox identical to this one except for the text."""
assert text
newBox = self.copy()
newBox.text = text
return newBox


class AtomicInlineLevelBox(InlineLevelBox):
"""An atomic box in an inline formatting context.

This inline-level box cannot be split for line breaks.

"""


class InlineBlockBox(AtomicInlineLevelBox, BlockContainerBox):
"""A box that is both inline-level and a block container.

It behaves as inline on the outside and as a block on the inside.

A non-replaced element with a 'display' value of 'inline-block' generates
an inline-block box.

"""


class ReplacedBox(Box):
"""A box whose content is replaced.

For example, ``<img>`` are replaced: their content is rendered externally
and is opaque from CSS’s point of view.

"""
def _Init_(self, elementTag, style, replacement):
super(ReplacedBox, self)._Init_(elementTag, style)
self.replacement = replacement


class BlockReplacedBox(ReplacedBox, BlockLevelBox):
"""A box that is both replaced and block-level.

A replaced element with a ``display`` value of ``block``, ``liste-item`` or
``table`` generates a block-level replaced box.

"""


class InlineReplacedBox(ReplacedBox, AtomicInlineLevelBox):
"""A box that is both replaced and inline-level.

A replaced element with a ``display`` value of ``inline``,
``inline-table``, or ``inline-block`` generates an inline-level replaced
box.

"""


class TableBox(BlockLevelBox, ParentBox):
"""Box for elements with ``display: table``"""
# Definitions for the rules generating anonymous table boxes
# http://www.w3.org/TR/CSS21/tables.html#anonymous-boxes
tabularContainer = True

def allChildren(self):
return itertools.chain(self.children, self.columnGroups)

def translate(self, dx=0, dy=0, ignoreFloats=False):
if dx == 0 and dy == 0:
return
self.columnPositions = [
position + dx for position in self.columnPositions]
return super(TableBox, self).translate(dx, dy, ignoreFloats)

def pageValues(self):
return (self.style['page'], self.style['page'])


class InlineTableBox(TableBox):
"""Box for elements with ``display: inline-table``"""


class TableRowGroupBox(ParentBox):
"""Box for elements with ``display: table-row-group``"""
properTableChild = True
internalTableOrCaption = True
tabularContainer = True
properParents = (TableBox, InlineTableBox)

# Default values. May be overriden on instances.
isHeader = False
isFooter = False


class TableRowBox(ParentBox):
"""Box for elements with ``display: table-row``"""
properTableChild = True
internalTableOrCaption = True
tabularContainer = True
properParents = (TableBox, InlineTableBox, TableRowGroupBox)


class TableColumnGroupBox(ParentBox):
"""Box for elements with ``display: table-column-group``"""
properTableChild = True
internalTableOrCaption = True
properParents = (TableBox, InlineTableBox)

# Default value. May be overriden on instances.
span = 1

# Columns groups never have margins or paddings
marginTop = 0
marginBottom = 0
marginLeft = 0
marginRight = 0

paddingTop = 0
paddingBottom = 0
paddingLeft = 0
paddingRight = 0

def getCells(self):
"""Return cells that originate in the group's columns."""
return [
cell for column in self.children for cell in column.getCells()]


# Not really a parent box, but pretending to be removes some corner cases.
class TableColumnBox(ParentBox):
"""Box for elements with ``display: table-column``"""
properTableChild = True
internalTableOrCaption = True
properParents = (TableBox, InlineTableBox, TableColumnGroupBox)

# Default value. May be overriden on instances.
span = 1

# Columns never have margins or paddings
marginTop = 0
marginBottom = 0
marginLeft = 0
marginRight = 0

paddingTop = 0
paddingBottom = 0
paddingLeft = 0
paddingRight = 0

def getCells(self):
"""Return cells that originate in the column.

May be overriden on instances.

"""
return []


class TableCellBox(BlockContainerBox):
"""Box for elements with ``display: table-cell``"""
internalTableOrCaption = True

# Default values. May be overriden on instances.
colspan = 1
rowspan = 1


class TableCaptionBox(BlockBox):
"""Box for elements with ``display: table-caption``"""
properTableChild = True
internalTableOrCaption = True
properParents = (TableBox, InlineTableBox)


class PageBox(ParentBox):
"""Box for a page.

Initially the whole document will be in the box for the root element.
During layout a new page box is created after every page break.

"""
def _Init_(self, pageType, style):
self.pageType = pageType
# Page boxes are not linked to any element.
super(PageBox, self)._Init_(
elementTag=None, style=style, children=[])

def _Repr_(self):
return '<%s %s>' % (type(self)._Name_, self.pageType)


class MarginBox(BlockContainerBox):
"""Box in page margins, as defined in CSS3 Paged Media"""
def _Init_(self, atKeyword, style):
self.atKeyword = atKeyword
# Margin boxes are not linked to any element.
super(MarginBox, self)._Init_(
elementTag=None, style=style, children=[])

def _Repr_(self):
return '<%s %s>' % (type(self)._Name_, self.atKeyword)
