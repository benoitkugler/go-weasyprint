"""
    weasyprint.css.computedValues
    ------------------------------

    Convert *specified* property values (the result of the cascade and
    inhertance) into *computed* values (that are inherited).

    :copyright: Copyright 2011-2018 Simon Sapin and contributors, see AUTHORS.
    :license: BSD, see LICENSE for details.

"""

from urllib.parse import unquote

from tinycss2.color3 import parseColor

from .. import text
from ..logger import LOGGER
from ..urls import getLinkAttribute
from .properties import INITIALVALUES, Dimension
from .utils import (
    ANGLETORADIANS, LENGTHUNITS, LENGTHSTOPIXELS, safeUrljoin)

ZEROPIXELS = Dimension(0, "px")


// Value in pixels of font-size for <absolute-size> keywords: 12pt (16px) for
// medium, and scaling factors given in CSS3 for others:
// http://www.w3.org/TR/css3-fonts/#font-size-prop
// TODO: this will need to be ordered to implement "smaller" and "larger"
FONTSIZEKEYWORDS = dict(
    # medium is 16px, others are a ratio of medium
    (name, INITIALVALUES["fontSize"] * a / b)
    for name, a, b in (
        ("xx-small", 3, 5),
        ("x-small", 3, 4),
        ("small", 8, 9),
        ("medium", 1, 1),
        ("large", 6, 5),
        ("x-large", 3, 2),
        ("xx-large", 2, 1),
    )
)

// These are unspecified, other than "thin" <="medium" <= "thick".
// Values are in pixels.
BORDERWIDTHKEYWORDS = {
    "thin": 1,
    "medium": 3,
    "thick": 5,
}
assert INITIALVALUES["borderTopWidth"] == BORDERWIDTHKEYWORDS["medium"]

// http://www.w3.org/TR/CSS21/fonts.html#propdef-font-weight
FONTWEIGHTRELATIVE = dict(
    bolder={
        100: 400,
        200: 400,
        300: 400,
        400: 700,
        500: 700,
        600: 900,
        700: 900,
        800: 900,
        900: 900,
    },
    lighter={
        100: 100,
        200: 100,
        300: 100,
        400: 100,
        500: 100,
        600: 400,
        700: 400,
        800: 700,
        900: 700,
    },
)

// http://www.w3.org/TR/css3-page/#size
// name=(width in pixels, height in pixels)
PAGESIZES = dict(
    a5=(
        Dimension(148, "mm"),
        Dimension(210, "mm"),
    ),
    a4=(
        Dimension(210, "mm"),
        Dimension(297, "mm"),
    ),
    a3=(
        Dimension(297, "mm"),
        Dimension(420, "mm"),
    ),
    b5=(
        Dimension(176, "mm"),
        Dimension(250, "mm"),
    ),
    b4=(
        Dimension(250, "mm"),
        Dimension(353, "mm"),
    ),
    letter=(
        Dimension(8.5, "in"),
        Dimension(11, "in"),
    ),
    legal=(
        Dimension(8.5, "in"),
        Dimension(14, "in"),
    ),
    ledger=(
        Dimension(11, "in"),
        Dimension(17, "in"),
    ),
)
// In "portrait" orientation.
for w, h in PAGESIZES.values():
    assert w.value < h.value

INITIALPAGESIZE = PAGESIZES["a4"]
INITIALVALUES["size"] = tuple(
    d.value * LENGTHSTOPIXELS[d.unit] for d in INITIALPAGESIZE)


def ComputingOrder():
    """Some computed values are required by others, so order matters."""
    first = [
        "fontStretch", "fontWeight", "fontFamily", "fontVariant",
        "fontStyle", "fontSize", "lineHeight", "marks"]
    order = sorted(INITIALVALUES)
    for name in first:
        order.remove(name)
    return tuple(first + order)


COMPUTINGORDER = ComputingOrder()

// Maps property names to functions returning the computed values
COMPUTERFUNCTIONS = {}


def registerComputer(name):
    """Decorator registering a property ``name`` for a function."""
    name = name.replace("-", "")

    def decorator(function):
        """Register the property ``name`` for ``function``."""
        COMPUTERFUNCTIONS[name] = function
        return function
    return decorator


def compute(element, pseudoType, specified, computed, parentStyle,
            rootStyle, baseUrl, targetCollector):
    """Create a dict of computed values.

    :param element: The HTML element these style apply to
    :param pseudoType: The type of pseudo-element, eg "before", None
    :param specified: A dict of specified values. Should contain
                      values for all properties.
    :param computed: A dict of already known computed values.
                     Only contains some properties (or none).
    :param parentStyle: A dict of computed values of the parent
                         element (should contain values for all properties),
                         or ``None`` if ``element`` is the root element.
    :param baseUrl: The base URL used to resolve relative URLs.
    :param targetCollector: A target collector used to get computed targets.

    """

    def computer():
        """Dummy object that holds attributes."""
        return 0

    computer.isRootElement = parentStyle is None
    if parentStyle is None:
        parentStyle = INITIALVALUES

    computer.element = element
    computer.pseudoType = pseudoType
    computer.specified = specified
    computer.computed = computed
    computer.parentStyle = parentStyle
    computer.rootStyle = rootStyle
    computer.baseUrl = baseUrl
    computer.targetCollector = targetCollector

    getter = COMPUTERFUNCTIONS.get

    for name in COMPUTINGORDER:
        if name in computed:
            # Already computed
            continue

        value = specified[name]
        function = getter(name)
        if function is not None:
            value = function(computer, name, value)
        # else: same as specified

        computed[name] = value

    computed["WeasySpecifiedDisplay"] = specified["display"]
    return computed


@registerComputer("background-image")
def backgroundImage(computer, name, values):
    """Compute lenghts in gradient background-image."""
    for type_, value in values:
        if type_ in ("linear-gradient", "radial-gradient"):
            value.stopPositions = tuple(
                length(computer, name, pos) if pos is not None else None
                for pos in value.stopPositions)
        if type_ == "radial-gradient":
            value.center, = backgroundPosition(
                computer, name, (value.center,))
            if value.sizeType == "explicit":
                value.size = lengthOrPercentageTuple(
                    computer, name, value.size)
    return values


@registerComputer("background-position")
def backgroundPosition(computer, name, values):
    """Compute lengths in background-position."""
    return tuple(
        (originX, length(computer, name, posX),
         originY, length(computer, name, posY))
        for originX, posX, originY, posY in values)


@registerComputer("transform-origin")
def lengthOrPercentageTuple(computer, name, values):
    """Compute the lists of lengths that can be percentages."""
    return tuple(length(computer, name, value) for value in values)


@registerComputer("border-spacing")
@registerComputer("size")
@registerComputer("clip")
def lengthTuple(computer, name, values):
    """Compute the properties with a list of lengths."""
    return tuple(length(computer, name, value, pixelsOnly=True)
                 for value in values)


@registerComputer("break-after")
@registerComputer("break-before")
def breakBeforeAfter(computer, name, value):
    """Compute the ``break-before`` and ``break-after`` properties."""
    # "always" is defined as an alias to "page" in multi-column
    # https://www.w3.org/TR/css3-multicol/#column-breaks
    if value == "always":
        return "page"
    else:
        return value


@registerComputer("top")
@registerComputer("right")
@registerComputer("left")
@registerComputer("bottom")
@registerComputer("margin-top")
@registerComputer("margin-right")
@registerComputer("margin-bottom")
@registerComputer("margin-left")
@registerComputer("height")
@registerComputer("width")
@registerComputer("min-width")
@registerComputer("min-height")
@registerComputer("max-width")
@registerComputer("max-height")
@registerComputer("padding-top")
@registerComputer("padding-right")
@registerComputer("padding-bottom")
@registerComputer("padding-left")
@registerComputer("text-indent")
@registerComputer("hyphenate-limit-zone")
@registerComputer("flex-basis")
def length(computer, name, value, fontSize=None, pixelsOnly=False):
    """Compute a length ``value``."""
    if value in ("auto", "content"):
        return value
    if value.value == 0:
        return 0 if pixelsOnly else ZEROPIXELS

    unit = value.unit
    if unit == "px":
        return value.value if pixelsOnly else value
    elif unit in LENGTHSTOPIXELS:
        # Convert absolute lengths to pixels
        result = value.value * LENGTHSTOPIXELS[unit]
    elif unit in ("em", "ex", "ch", "rem"):
        if fontSize is None:
            fontSize = computer.computed["fontSize"]
        if unit == "ex":
            # TODO: cache
            result = value.value * fontSize * exRatio(computer.computed)
        elif unit == "ch":
            # TODO: cache
            # TODO: use context to use @font-face fonts
            layout = text.Layout(
                context=None, fontSize=fontSize,
                style=computer.computed)
            layout.setText("0")
            line, = layout.iterLines()
            logicalWidth, _ = text.getSize(line, computer.computed)
            result = value.value * logicalWidth
        elif unit == "em":
            result = value.value * fontSize
        elif unit == "rem":
            result = value.value * computer.rootStyle["fontSize"]
    else:
        # A percentage or "auto": no conversion needed.
        return value

    return result if pixelsOnly else Dimension(result, "px")


@registerComputer("bleed-left")
@registerComputer("bleed-right")
@registerComputer("bleed-top")
@registerComputer("bleed-bottom")
def bleed(computer, name, value):
    if value == "auto":
        if "crop" in computer.computed["marks"]:
            return Dimension(8, "px")  # 6pt
        else:
            return Dimension(0, "px")
    else:
        return length(computer, name, value)


@registerComputer("letter-spacing")
def pixelLength(computer, name, value):
    if value == "normal":
        return value
    else:
        return length(computer, name, value, pixelsOnly=True)


@registerComputer("background-size")
def backgroundSize(computer, name, values):
    """Compute the ``background-size`` properties."""
    return tuple(
        value if value in ("contain", "cover") else
        lengthOrPercentageTuple(computer, name, value)
        for value in values)


@registerComputer("border-top-width")
@registerComputer("border-right-width")
@registerComputer("border-left-width")
@registerComputer("border-bottom-width")
@registerComputer("column-rule-width")
@registerComputer("outline-width")
def borderWidth(computer, name, value):
    """Compute the ``border-*-width`` properties."""
    style = computer.computed[name.replace("width", "style")]
    if style in ("none", "hidden"):
        return 0

    if value in BORDERWIDTHKEYWORDS:
        return BORDERWIDTHKEYWORDS[value]

    if isinstance(value, int):
        # The initial value can get here, but length() would fail as
        # it does not have a "unit" attribute.
        return value

    return length(computer, name, value, pixelsOnly=True)


@registerComputer("column-width")
def columnWidth(computer, name, value):
    """Compute the ``column-width`` property."""
    return length(computer, name, value, pixelsOnly=True)


@registerComputer("border-top-left-radius")
@registerComputer("border-top-right-radius")
@registerComputer("border-bottom-left-radius")
@registerComputer("border-bottom-right-radius")
def borderRadius(computer, name, values):
    """Compute the ``border-*-radius`` properties."""
    return tuple(length(computer, name, value) for value in values)


@registerComputer("column-gap")
def columnGap(computer, name, value):
    """Compute the ``column-gap`` property."""
    if value == "normal":
        value = Dimension(1, "em")
    return length(computer, name, value, pixelsOnly=True)


def computeAttrFunction(computer, values):
    # TODO: use real token parsing instead of casting with Python types
    funcName, value = values
    assert funcName == "attr()"
    attrName, typeOrUnit, fallback = value
    # computer.element sometimes is None
    # computer.element sometimes is a "PageType" object without .get()
    # so wrapt the .get() into try and return None instead of crashing
    try:
        attrValue = computer.element.get(attrName, fallback)
        if typeOrUnit == "string":
            pass  # Keep the string
        elif typeOrUnit == "url":
            if attrValue.startswith("#"):
                attrValue = ("internal", unquote(attrValue[1:]))
            else:
                attrValue = (
                    "external", safeUrljoin(computer.baseUrl, attrValue))
        elif typeOrUnit == "color":
            attrValue = parseColor(attrValue.strip())
        elif typeOrUnit == "integer":
            attrValue = int(attrValue.strip())
        elif typeOrUnit == "number":
            attrValue = float(attrValue.strip())
        elif typeOrUnit == "%":
            attrValue = Dimension(float(attrValue.strip()), "%")
            typeOrUnit = "length"
        elif typeOrUnit in LENGTHUNITS:
            attrValue = Dimension(float(attrValue.strip()), typeOrUnit)
            typeOrUnit = "length"
        elif typeOrUnit in ANGLETORADIANS:
            attrValue = Dimension(float(attrValue.strip()), typeOrUnit)
            typeOrUnit = "angle"
    except Exception:
        return
    return (typeOrUnit, attrValue)


def ContentList(computer, values):
    computedValues = []
    for value in values:
        if value[0] in ("string", "content", "url", "quote", "leader()"):
            computedValue = value
        elif value[0] == "attr()":
            assert value[1][1] == "string"
            computedValue = computeAttrFunction(computer, value)
        elif value[0] in ("counter()", "counters()", "content()", "string()"):
            # Other values need layout context, their computed value cannot be
            # better than their specified value yet.
            # See build.computeContentList.
            computedValue = value
        elif value[0] in (
                "target-counter()", "target-counters()", "target-text()"):
            anchorToken = value[1][0]
            if anchorToken[0] == "attr()":
                attr = computeAttrFunction(computer, anchorToken)
                if attr is None:
                    computedValue = None
                else:
                    computedValue = (value[0], (
                        (attr,) + value[1][1:]))
            else:
                computedValue = value
            if computer.targetCollector and computedValue:
                computer.targetCollector.collectComputedTarget(
                    computedValue[1][0])
        if computedValue is None:
            LOGGER.warning("Unable to compute %s\"s value for content: %s" % (
                computer.element, ", ".join(str(item) for item in value)))
        else:
            computedValues.append(computedValue)

    return tuple(computedValues)


@registerComputer("bookmark-label")
def bookmarkLabel(computer, name, values):
    """Compute the ``bookmark-label`` property."""
    return ContentList(computer, values)


@registerComputer("string-set")
def stringSet(computer, name, values):
    """Compute the ``string-set`` property."""
    # Spec asks for strings after custom keywords, but we allow content-lists
    return tuple(
        (stringSet[0], ContentList(computer, stringSet[1]))
        for stringSet in values)


@registerComputer("content")
def content(computer, name, values):
    """Compute the ``content`` property."""
    if len(values) == 1:
        value, = values
        if value == "normal":
            return "inhibit" if computer.pseudoType else "contents"
        elif value == "none":
            return "inhibit"
    return ContentList(computer, values)


@registerComputer("display")
def display(computer, name, value):
    """Compute the ``display`` property.

    See http://www.w3.org/TR/CSS21/visuren.html#dis-pos-flo

    """
    float_ = computer.specified["float"]
    position = computer.specified["position"]
    if position in ("absolute", "fixed") or float_ != "none" or \
            computer.isRootElement:
        if value == "inline-table":
            return"table"
        elif value in ("inline", "table-row-group", "table-column",
                       "table-column-group", "table-header-group",
                       "table-footer-group", "table-row", "table-cell",
                       "table-caption", "inline-block"):
            return "block"
    return value


@registerComputer("float")
def computeFloat(computer, name, value):
    """Compute the ``float`` property.

    See http://www.w3.org/TR/CSS21/visuren.html#dis-pos-flo

    """
    if computer.specified["position"] in ("absolute", "fixed"):
        return "none"
    else:
        return value


@registerComputer("font-size")
def fontSize(computer, name, value):
    """Compute the ``font-size`` property."""
    if value in FONTSIZEKEYWORDS:
        return FONTSIZEKEYWORDS[value]
    # TODO: support "larger" and "smaller"

    parentFontSize = computer.parentStyle["fontSize"]
    if value.unit == "%":
        return value.value * parentFontSize / 100.
    else:
        return length(computer, name, value, pixelsOnly=True,
                      fontSize=parentFontSize)


@registerComputer("font-weight")
def fontWeight(computer, name, value):
    """Compute the ``font-weight`` property."""
    if value == "normal":
        return 400
    elif value == "bold":
        return 700
    elif value in ("bolder", "lighter"):
        parentValue = computer.parentStyle["fontWeight"]
        return FONTWEIGHTRELATIVE[value][parentValue]
    else:
        return value


@registerComputer("line-height")
def lineHeight(computer, name, value):
    """Compute the ``line-height`` property."""
    if value == "normal":
        return value
    elif not value.unit:
        return ("NUMBER", value.value)
    elif value.unit == "%":
        factor = value.value / 100.
        fontSizeValue = computer.computed["fontSize"]
        pixels = factor * fontSizeValue
    else:
        pixels = length(computer, name, value, pixelsOnly=True)
    return ("PIXELS", pixels)


@registerComputer("anchor")
def anchor(computer, name, values):
    """Compute the ``anchor`` property."""
    if values != "none":
        _, key = values
        anchorName = computer.element.get(key) or None
        computer.targetCollector.collectAnchor(anchorName)
        return anchorName


@registerComputer("link")
def link(computer, name, values):
    """Compute the ``link`` property."""
    if values == "none":
        return None
    else:
        type_, value = values
        if type_ == "attr()":
            return getLinkAttribute(
                computer.element, value, computer.baseUrl)
        else:
            return values


@registerComputer("lang")
def lang(computer, name, values):
    """Compute the ``lang`` property."""
    if values == "none":
        return None
    else:
        type_, key = values
        if type_ == "attr()":
            return computer.element.get(key) or None
        elif type_ == "string":
            return key


@registerComputer("tab-size")
def tabSize(computer, name, value):
    """Compute the ``tab-size`` property."""
    if isinstance(value, int):
        return value
    else:
        return length(computer, name, value)


@registerComputer("transform")
def transform(computer, name, value):
    """Compute the ``transform`` property."""
    result = []
    for function, args in value:
        if function == "translate":
            args = lengthOrPercentageTuple(computer, name, args)
        result.append((function, args))
    return tuple(result)


@registerComputer("vertical-align")
def verticalAlign(computer, name, value):
    """Compute the ``vertical-align`` property."""
    # Use +/- half an em for super and sub, same as Pango.
    # (See the SUPERSUBRISE constant in pango-markup.c)
    if value in ("baseline", "middle", "text-top", "text-bottom",
                 "top", "bottom"):
        return value
    elif value == "super":
        return computer.computed["fontSize"] * 0.5
    elif value == "sub":
        return computer.computed["fontSize"] * -0.5
    elif value.unit == "%":
        height, _ = strutLayout(computer.computed)
        return height * value.value / 100.
    else:
        return length(computer, name, value, pixelsOnly=True)


@registerComputer("word-spacing")
def wordSpacing(computer, name, value):
    """Compute the ``word-spacing`` property."""
    if value == "normal":
        return 0
    else:
        return length(computer, name, value, pixelsOnly=True)


def strutLayout(style, context=None):
    """Return a tuple of the used value of ``line-height`` and the baseline.

    The baseline is given from the top edge of line height.

    """
    # TODO: always get the real value for `context`? (if we really careâ€¦)

    if style["fontSize"] == 0:
        return 0, 0

    if context:
        key = (
            style["fontSize"], style["fontLanguageOverride"], style["lang"],
            tuple(style["fontFamily"]), style["fontStyle"],
            style["fontStretch"], style["fontWeight"], style["lineHeight"])
        if key in context.strutLayouts:
            return context.strutLayouts[key]

    layout = text.Layout(
        context=context, fontSize=style["fontSize"], style=style)
    line, = layout.iterLines()
    _, _, _, _, textHeight, baseline = text.firstLineMetrics(
        line, "", layout, resumeAt=None, spaceCollapse=False, style=style)
    if style["lineHeight"] == "normal":
        result = textHeight, baseline
        if context:
            context.strutLayouts[key] = result
        return result
    type_, lineHeight = style["lineHeight"]
    if type_ == "NUMBER":
        lineHeight *= style["fontSize"]
    result = lineHeight, baseline + (lineHeight - textHeight) / 2
    if context:
        context.strutLayouts[key] = result
    return result


def exRatio(style):
    """Return the ratio 1ex/fontSize, according to given style."""
    fontSize = 1000  # big value
    # TODO: use context to use @font-face fonts
    layout = text.Layout(context=None, fontSize=fontSize, style=style)
    layout.setText("x")
    line, = layout.iterLines()
    _, inkHeightAboveBaseline = text.getInkPosition(line)
    # Zero means some kind of failure, fallback is 0.5.
    # We round to try keeping exact values that were altered by Pango.
    return round(-inkHeightAboveBaseline / fontSize, 5) or 0.5
