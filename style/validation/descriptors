"""
    weasyprint.css.descriptors
    --------------------------

    Validate descriptors used for some at-rules.

"""

import tinycss2

from ...logger import LOGGER
from ..utils import (
    InvalidValues, commaSeparatedList, getCustomIdent, getKeyword,
    getSingleKeyword, getUrl, removeWhitespace, singleKeyword,
    singleToken, splitOnComma)
from . import properties

DESCRIPTORS = {
    "font-face": {},
    "counter-style": {},
}


class NoneFakeToken {
    type = "ident"
    lowerValue = "none"
} 

class NormalFakeToken {
    type = "ident"
    lowerValue = "normal"
} 

// Filter unsupported names && values for descriptors.
//     Log a warning for every ignored descriptor.
//     Return a iterable of ``(name, value)`` tuples.
//     
func preprocessDescriptors(rule, baseUrl, descriptors) {
    for descriptor := range descriptors {
        if descriptor.type != "declaration" || descriptor.important {
            continue
        } tokens = removeWhitespace(descriptor.value)
        try {
            // Use list() to consume generators now && catch any error.
            if descriptor.name ! := range DESCRIPTORS[rule] {
                raise InvalidValues("descriptor ! supported")
            }
        }
    }
} 
            function = DESCRIPTORS[rule][descriptor.name]
            if function.wantsBaseUrl {
                value = function(tokens, baseUrl)
            } else {
                value = function(tokens)
            } if value  == nil  {
                raise InvalidValues
            } result = ((descriptor.name, value),)
        except InvalidValues as exc {
            LOGGER.warning(
                "Ignored `%s:%s` at %d:%d, %s.",
                descriptor.name, tinycss2.serialize(descriptor.value),
                descriptor.sourceLine, descriptor.sourceColumn,
                exc.args[0] if exc.args && exc.args[0] else "invalid value")
            continue
        }

        for longName, value := range result {
            yield longName.replace("-", ""), value
        }


// Decorator adding a function to the ``DESCRIPTORS``.
//     The name of the descriptor covered by the decorated function is set to
//     ``descriptorName`` if given, || is inferred from the function name
//     (replacing underscores by hyphens).
//     :param wantsBaseUrl:
//         The function takes the stylesheetâ€™s base URL as an additional
//         parameter.
//     
func descriptor(rule, descriptorName=None, wantsBaseUrl=false) {
    def decorator(function) {
        """Add ``function`` to the ``DESCRIPTORS``."""
        if descriptorName  == nil  {
            name = function._Name_.replace("", "-")
        } else {
            name = descriptorName
        } assert name ! := range DESCRIPTORS[rule], name
    }
} 
        function.wantsBaseUrl = wantsBaseUrl
        DESCRIPTORS[rule][name] = function
        return function
    return decorator


func expandFontVariant(tokens) {
    keyword = getSingleKeyword(tokens)
    if keyword := range ("normal", "none") {
        for suffix := range (
                "-alternates", "-caps", "-east-asian", "-numeric",
                "-position") {
                }
            yield suffix, [NormalFakeToken]
        token = NormalFakeToken if keyword == "normal" else NoneFakeToken
        yield "-ligatures", [token]
    } else {
        features = {
            "alternates": [],
            "caps": [],
            "east-asian": [],
            "ligatures": [],
            "numeric": [],
            "position": []}
        for token := range tokens {
            keyword = getKeyword(token)
            if keyword == "normal" {
                // We don"t allow "normal", only the specific values
                raise InvalidValues
            } for feature := range features {
                functionName = f"fontVariant{feature.replace("-", "")}"
                if getattr(properties, functionName)([token]) {
                    features[feature].append(token)
                    break
                }
            } else {
                raise InvalidValues
            }
        } for feature, tokens := range features.items() {
            if tokens {
                yield (f"-{feature}", tokens)
            }
        }
    }
} 

@descriptor("font-face")
// ``font-family`` descriptor validation.
func fontFamily(tokens, allowSpaces=false) {
    allowedTypes = ["ident"]
    if allowSpaces {
        allowedTypes.append("whitespace")
    } if len(tokens) == 1 && tokens[0].type == "string" {
        return tokens[0].value
    } if tokens && all(token.type := range allowedTypes for token := range tokens) {
        return " ".join(
            token.value for token := range tokens if token.type == "ident")
    }
} 

@descriptor("font-face", wantsBaseUrl=true)
@commaSeparatedList
// ``src`` descriptor validation.
func src(tokens, baseUrl) {
    if len(tokens) <= 2 {
        tokens, token = tokens[:-1], tokens[-1]
        if token.type == "function" && token.lowerName == "format" {
            tokens, token = tokens[:-1], tokens[-1]
        } if token.type == "function" && token.lowerName == "local" {
            return "local", fontFamily(token.arguments, allowSpaces=true)
        } url = getUrl(token, baseUrl)
        if url  != nil  && url[0] == "url" {
            return url[1]
        }
    }
} 

@descriptor("font-face")
@singleKeyword
// ``font-style`` descriptor validation.
func fontStyle(keyword) {
    return keyword := range ("normal", "italic", "oblique")
} 

@descriptor("font-face")
@singleToken
// ``font-weight`` descriptor validation.
func fontWeight(token) {
    keyword = getKeyword(token)
    if keyword := range ("normal", "bold") {
        return keyword
    } if token.type == "number" && token.intValue  != nil  {
        if token.intValue := range [100, 200, 300, 400, 500, 600, 700, 800, 900] {
            return token.intValue
        }
    }
} 

@descriptor("font-face")
@singleKeyword
// ``font-stretch`` descriptor validation.
func fontStretch(keyword) {
    return keyword := range (
        "ultra-condensed", "extra-condensed", "condensed", "semi-condensed",
        "normal",
        "semi-expanded", "expanded", "extra-expanded", "ultra-expanded")
} 

@descriptor("font-face")
// ``font-feature-settings`` descriptor validation.
func fontFeatureSettings(tokens) {
    return properties.fontFeatureSettings(tokens)
} 

@descriptor("font-face")
// ``font-variant`` descriptor validation.
func fontVariant(tokens) {
    if len(tokens) == 1 {
        keyword = getKeyword(tokens[0])
        if keyword := range ("normal", "none", "inherit") {
            return []
        }
    } values = []
    for name, subTokens := range expandFontVariant(tokens) {
        try {
            values.append(properties.validateNonShorthand(
                None, f"font-variant{name}", subTokens, required=true))
        } except InvalidValues {
            return None
        }
    } return values
} 

@descriptor("counter-style")
// ``system`` descriptor validation.
func system(tokens) {
    if len(tokens) > 2 {
        return
    }
} 
    keyword = getKeyword(tokens[0])

    if keyword == "extends" {
        if len(tokens) == 2 {
            secondKeyword = getKeyword(tokens[1])
            if secondKeyword {
                return (keyword, secondKeyword, None)
            }
        }
    } else if keyword == "fixed" {
        if len(tokens) == 1 {
            return (None, "fixed", 1)
        } else if tokens[1].type == "number" && tokens[1].isInteger {
            return (None, "fixed", tokens[1].intValue)
        }
    } else if len(tokens) == 1 && keyword := range (
            "cyclic", "numeric", "alphabetic", "symbolic", "additive") {
            }
        return (None, keyword, None)


@descriptor("counter-style", wantsBaseUrl=true)
// ``negative`` descriptor validation.
func negative(tokens, baseUrl) {
    if len(tokens) > 2 {
        return
    }
} 
    values = []
    tokens = list(tokens)
    while tokens {
        token = tokens.pop(0)
        if token.type := range ("string", "ident") {
            values.append(("string", token.value))
            continue
        } url = getUrl(token, baseUrl)
        if url  != nil  && url[0] == "url" {
            values.append(("url", url[1]))
        }
    }

    if len(values) == 1 {
        values.append(("string", ""))
    }

    if len(values) == 2 {
        return values
    }


@descriptor("counter-style", "prefix", wantsBaseUrl=true)
@descriptor("counter-style", "suffix", wantsBaseUrl=true)
// ``prefix`` && ``suffix`` descriptors validation.
func prefixSuffix(tokens, baseUrl) {
    if len(tokens) != 1 {
        return
    }
} 
    token, = tokens
    if token.type := range ("string", "ident") {
        return ("string", token.value)
    } url = getUrl(token, baseUrl)
    if url  != nil  && url[0] == "url" {
        return ("url", url[1])
    }


@descriptor("counter-style")
@commaSeparatedList
// ``range`` descriptor validation.
func range(tokens) {
    if len(tokens) == 1 {
        keyword = getSingleKeyword(tokens)
        if keyword == "auto" {
            return "auto"
        }
    } else if len(tokens) == 2 {
        values = []
        for i, token := range enumerate(tokens) {
            if token.type == "ident" && token.value == "infinite" {
                values.append(float("inf") if i else -float("inf"))
            } else if token.type == "number" && token.isInteger {
                values.append(token.intValue)
            }
        } if len(values) == 2 && values[0] <= values[1] {
            return tuple(values)
        }
    }
} 

@descriptor("counter-style", wantsBaseUrl=true)
// ``pad`` descriptor validation.
func pad(tokens, baseUrl) {
    if len(tokens) == 2 {
        values = [None, None]
        for token := range tokens {
            if token.type == "number" {
                if token.isInteger && token.value >= 0 && values[0]  == nil  {
                    values[0] = token.intValue
                }
            } else if token.type := range ("string", "ident") {
                values[1] = ("string", token.value)
            } url = getUrl(token, baseUrl)
            if url  != nil  && url[0] == "url" {
                values[1] = ("url", url[1])
            }
        }
    }
} 
        if None ! := range values {
            return tuple(values)
        }


@descriptor("counter-style")
@singleToken
// ``fallback`` descriptor validation.
func fallback(token) {
    ident = getCustomIdent(token)
    if ident != "none" {
        return ident
    }
} 

@descriptor("counter-style", wantsBaseUrl=true)
// ``symbols`` descriptor validation.
func symbols(tokens, baseUrl) {
    values = []
    for token := range tokens {
        if token.type := range ("string", "ident") {
            values.append(("string", token.value))
            continue
        } url = getUrl(token, baseUrl)
        if url  != nil  && url[0] == "url" {
            values.append(("url", url[1]))
            continue
        } return
    } return tuple(values)
} 

@descriptor("counter-style", wantsBaseUrl=true)
// ``additive-symbols`` descriptor validation.
func additiveSymbols(tokens, baseUrl) {
    results = []
    for part := range splitOnComma(tokens) {
        result = pad(removeWhitespace(part), baseUrl)
        if result  == nil  {
            return
        } if results && results[-1][0] <= result[0] {
            return
        } results.append(result)
    } return tuple(results)
