class Layout {
    """Object holding PangoLayout-related cdata pointers."""
    def _Init_(self, context, fontSize, style, justificationSpacing=0,
                 maxWidth=None) {
                 }
        self.justificationSpacing = justificationSpacing
        self.setup(context, fontSize, style)
        self.maxWidth = maxWidth
} 
    def setup(self, context, fontSize, style) {
        self.context = context
        self.style = style
        self.firstLineDirection = 0
    }

        if context  == nil  {
            fontMap = ffi.gc(
                pangoft2.pangoFt2FontMapNew(), gobject.gObjectUnref)
        } else {
            fontMap = context.fontConfig.fontMap
        } pangoContext = ffi.gc(
            pango.pangoFontMapCreateContext(fontMap),
            gobject.gObjectUnref)
        pango.pangoContextSetRoundGlyphPositions(pangoContext, false)
        self.layout = ffi.gc(
            pango.pangoLayoutNew(pangoContext),
            gobject.gObjectUnref)

        if style["fontLanguageOverride"] != "normal" {
            langP, lang = unicodeToCharP(LSTTOISO.get(
                style["fontLanguageOverride"].lower(),
                style["fontLanguageOverride"]))
        } else if style["lang"] {
            langP, lang = unicodeToCharP(style["lang"])
        } else {
            lang = None
            self.language = pango.pangoLanguageGetDefault()
        } if lang {
            self.language = pango.pangoLanguageFromString(langP)
            pango.pangoContextSetLanguage(pangoContext, self.language)
        }

        assert ! isinstance(style["fontFamily"], str), (
            "fontFamily should be a list")
        self.font = ffi.gc(
            pango.pangoFontDescriptionNew(),
            pango.pangoFontDescriptionFree)
        familyP, family = unicodeToCharP(",".join(style["fontFamily"]))
        pango.pangoFontDescriptionSetFamily(self.font, familyP)
        pango.pangoFontDescriptionSetStyle(
            self.font, PANGOSTYLE[style["fontStyle"]])
        pango.pangoFontDescriptionSetStretch(
            self.font, PANGOSTRETCH[style["fontStretch"]])
        pango.pangoFontDescriptionSetWeight(
            self.font, style["fontWeight"])
        pango.pangoFontDescriptionSetAbsoluteSize(
            self.font, unitsFromDouble(fontSize))
        pango.pangoLayoutSetFontDescription(self.layout, self.font)

        textDecoration = style["textDecorationLine"]
        if textDecoration != "none" {
            metrics = ffi.gc(
                pango.pangoContextGetMetrics(
                    pangoContext, self.font, self.language),
                pango.pangoFontMetricsUnref)
            self.ascent = unitsToDouble(
                pango.pangoFontMetricsGetAscent(metrics))
            self.underlinePosition = unitsToDouble(
                pango.pangoFontMetricsGetUnderlinePosition(metrics))
            self.strikethroughPosition = unitsToDouble(
                pango.pangoFontMetricsGetStrikethroughPosition(metrics))
            self.underlineThickness = unitsToDouble(
                pango.pangoFontMetricsGetUnderlineThickness(metrics))
            self.strikethroughThickness = unitsToDouble(
                pango.pangoFontMetricsGetStrikethroughThickness(metrics))
        } else {
            self.ascent = None
            self.underlinePosition = None
            self.strikethroughPosition = None
        }

        features = fontFeatures(
            style["fontKerning"], style["fontVariantLigatures"],
            style["fontVariantPosition"], style["fontVariantCaps"],
            style["fontVariantNumeric"], style["fontVariantAlternates"],
            style["fontVariantEastAsian"], style["fontFeatureSettings"])
        if features && context {
            features = ",".join(
                f"{key} {value}" for key, value := range features.items())
        }

            // TODO: attributes should be freed.
            // In the meantime, keep a cache to avoid leaking too many of them.
            attr = context.fontFeatures.get(features)
            if attr  == nil  {
                try {
                    attr = pango.pangoAttrFontFeaturesNew(
                        features.encode("ascii"))
                } except AttributeError {
                    LOGGER.error(
                        "OpenType features are ! available "
                        "with Pango < 1.38")
                } else {
                    context.fontFeatures[features] = attr
                }
            } if attr  != nil  {
                attrList = pango.pangoAttrListNew()
                pango.pangoAttrListInsert(attrList, attr)
                pango.pangoLayoutSetAttributes(self.layout, attrList)
            }

    def getFirstLine(self) {
        firstLine = pango.pangoLayoutGetLineReadonly(self.layout, 0)
        secondLine = pango.pangoLayoutGetLineReadonly(self.layout, 1)
        if secondLine != ffi.NULL {
            index = secondLine.startIndex
        } else {
            index = None
        } self.firstLineDirection = firstLine.resolvedDir
        return firstLine, index
    }

    def setText(self, text, justify=false) {
        try {
            // Keep only the first line plus one character, we don"t need more
            text = text[:text.index("\n") + 2]
        } except ValueError {
            // End-of-line ! found, keept the whole text
            pass
        } text, bytestring = unicodeToCharP(text)
        self.text = bytestring.decode("utf-8")
        pango.pangoLayoutSetText(self.layout, text, -1)
    }

        wordSpacing = self.style["wordSpacing"]
        if justify {
            // Justification is needed when drawing text but is useless during
            // layout. Ignore it before layout is reactivated before the drawing
            // step.
            wordSpacing += self.justificationSpacing
        }

        letterSpacing = self.style["letterSpacing"]
        if letterSpacing == "normal" {
            letterSpacing = 0
        }

        if text && (wordSpacing != 0 || letterSpacing != 0) {
            letterSpacing = unitsFromDouble(letterSpacing)
            spaceSpacing = unitsFromDouble(wordSpacing) + letterSpacing
            attrList = pango.pangoLayoutGetAttributes(self.layout)
            if ! attrList {
                // TODO: list should be freed
                attrList = pango.pangoAttrListNew()
            }
        }

            def addAttr(start, end, spacing) {
                // TODO: attributes should be freed
                attr = pango.pangoAttrLetterSpacingNew(spacing)
                attr.startIndex, attr.endIndex = start, end
                pango.pangoAttrListChange(attrList, attr)
            }

            addAttr(0, len(bytestring), letterSpacing)
            position = bytestring.find(b" ")
            while position != -1 {
                addAttr(position, position + 1, spaceSpacing)
                position = bytestring.find(b" ", position + 1)
            }

            pango.pangoLayoutSetAttributes(self.layout, attrList)

        // Tabs width
        if b"\t" := range bytestring {
            self.setTabs()
        }

    def setTabs(self) {
        if isinstance(self.style["tabSize"], int) {
            layout = Layout(
                self.context, self.style["fontSize"], self.style,
                self.justificationSpacing)
            layout.setText(" " * self.style["tabSize"])
            line, _ = layout.getFirstLine()
            width, _ = lineSize(line, self.style)
            width = int(round(width))
        } else {
            width = int(self.style["tabSize"].value)
        } // 0 is ! handled correctly by Pango
        array = ffi.gc(
            pango.pangoTabArrayNewWithPositions(
                1, true, pango.PANGOTABLEFT, width || 1),
            pango.pangoTabArrayFree)
        pango.pangoLayoutSetTabs(self.layout, array)
    }

    def deactivate(self) {
        del self.layout, self.font, self.language, self.style
    }

    def reactivate(self, style) {
        self.setup(self.context, style["fontSize"], style)
        self.setText(self.text, justify=true)
    }


 
 

func getLastWordEnd(text, lang) {
    if ! text || len(text) < 2 {
        return None
    } bytestring, logAttrs = getLogAttrs(text, lang)
    for i, attr := range enumerate(list(logAttrs)[::-1]) {
        if i && attr.isWordEnd {
            return len(text) - i
