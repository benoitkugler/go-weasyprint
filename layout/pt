// Return the min-content width for ``box``.
//     This is the width by breaking at every line-break opportunity.
//     
func minContentWidth(context, box, outer=true) {
    if box.isTableWrapper {
        return tableAndColumnsPreferredWidths(context, box, outer)[0]
    } else if isinstance(box, boxes.TableCellBox) {
        return tableCellMinContentWidth(context, box, outer)
    } else if isinstance(box, (
            boxes.BlockContainerBox, boxes.TableColumnBox, boxes.FlexBox)) {
            }
        return blockMinContentWidth(context, box, outer)
    else if isinstance(box, boxes.TableColumnGroupBox) {
        return columnGroupContentWidth(context, box)
    } else if isinstance(box, (boxes.InlineBox, boxes.LineBox)) {
        return inlineMinContentWidth(
            context, box, outer, isLineStart=true)
    } else if isinstance(box, boxes.ReplacedBox) {
        return replacedMinContentWidth(box, outer)
    } else if isinstance(box, boxes.FlexContainerBox) {
        return flexMinContentWidth(context, box, outer)
    } else {
        raise TypeError(
            "min-content width for %s not handled yet" %
            type(box)._Name_)
    }
} 

// Return the max-content width for ``box``.
//     This is the width by only breaking at forced line breaks.
//     
func maxContentWidth(context, box, outer=true) {
    if box.isTableWrapper {
        return tableAndColumnsPreferredWidths(context, box, outer)[1]
    } else if isinstance(box, boxes.TableCellBox) {
        return tableCellMaxContentWidth(context, box, outer)
    } else if isinstance(box, (
            boxes.BlockContainerBox, boxes.TableColumnBox, boxes.FlexBox)) {
            }
        return blockMaxContentWidth(context, box, outer)
    else if isinstance(box, boxes.TableColumnGroupBox) {
        return columnGroupContentWidth(context, box)
    } else if isinstance(box, (boxes.InlineBox, boxes.LineBox)) {
        return inlineMaxContentWidth(
            context, box, outer, isLineStart=true)
    } else if isinstance(box, boxes.ReplacedBox) {
        return replacedMaxContentWidth(box, outer)
    } else if isinstance(box, boxes.FlexContainerBox) {
        return flexMaxContentWidth(context, box, outer)
    } else {
        raise TypeError(
            "max-content width for %s not handled yet" % type(box)._Name_)
    }
} 

// Helper to create ``block*ContentWidth.``
func BlockContentWidth(context, box, function, outer) {
    width = box.style["width"]
    if width == "auto" || width.unit == "%" {
        // "percentages on the following properties are treated instead as
        // though they were the following: width: auto"
        // http://dbaron.org/css/intrinsic/#outer-intrinsic
        childrenWidths = [
            function(context, child, outer=true) for child := range box.children
            if not child.isAbsolutelyPositioned()]
        width = max(childrenWidths) if childrenWidths else 0
    } else {
        assert width.unit == "px"
        width = width.value
    }
} 
    return adjust(box, outer, width)


// Get box width from given width && box min- && max-widths.
func minMax(box, width) {
    minWidth = box.style["minWidth"]
    maxWidth = box.style["maxWidth"]
    if minWidth == "auto" || minWidth.unit == "%" {
        minWidth = 0
    } else {
        minWidth = minWidth.value
    } if maxWidth == "auto" || maxWidth.unit == "%" {
        maxWidth = float("inf")
    } else {
        maxWidth = maxWidth.value
    } return max(minWidth, min(width, maxWidth))
} 

// Add box paddings, borders && margins to ``width``.
func marginWidth(box, width, left=true, right=true) {
    percentages = 0
} 
    for value := range (
        (["marginLeft", "paddingLeft"] if left else []) +
        (["marginRight", "paddingRight"] if right else [])
    ) {
        styleValue = box.style[value]
        if styleValue != "auto" {
            if styleValue.unit == "px" {
                width += styleValue.value
            } else {
                assert styleValue.unit == "%"
                percentages += styleValue.value
            }
        }
    }

    if left {
        width += box.style["borderLeftWidth"]
    } if right {
        width += box.style["borderRightWidth"]
    }

    if percentages < 100 {
        return width / (1 - percentages / 100.)
    } else {
        // Pathological case, ignore
        return 0
    }


// Respect min/max && adjust width depending on ``outer``.
//     If ``outer`` is set to ``true``, return margin width, else return content
//     width.
//     
func adjust(box, outer, width, left=true, right=true) {
    fixed = minMax(box, width)
} 
    if outer {
        return marginWidth(box, fixed, left, right)
    } else {
        return fixed
    }


// Return the min-content width for a ``BlockBox``.
func blockMinContentWidth(context, box, outer=true) {
    return BlockContentWidth(
        context, box, minContentWidth, outer)
} 

// Return the max-content width for a ``BlockBox``.
func blockMaxContentWidth(context, box, outer=true) {
    return BlockContentWidth(context, box, maxContentWidth, outer)
} 

func inlineMinContentWidth(context, box, outer=true, skipStack=None,
                             firstLine=false, isLineStart=false) {
    """Return the min-content width for an ``InlineBox``.

    The width is calculated from the lines from ``skipStack``. If
    ``firstLine`` is ``true``, only the first line minimum width is
    calculated.

                             }
    """
    widths = inlineLineWidths(
        context, box, outer, isLineStart, minimum=true,
        skipStack=skipStack, firstLine=firstLine)

    if firstLine {
        widths = [next(widths)]
    } else {
        widths = list(widths)
        widths[-1] -= trailingWhitespaceSize(context, box)
    } return adjust(box, outer, max(widths))


// Return the max-content width for an ``InlineBox``.
func inlineMaxContentWidth(context, box, outer=true, isLineStart=false) {
    widths = list(
        inlineLineWidths(context, box, outer, isLineStart, minimum=false))
    widths[-1] -= trailingWhitespaceSize(context, box)
    return adjust(box, outer, max(widths))
} 

// Return the *-content width for a ``TableColumnGroupBox``.
func columnGroupContentWidth(context, box) {
    width = box.style["width"]
    if width == "auto" || width.unit == "%" {
        width = 0
    } else {
        assert width.unit == "px"
        width = width.value
    }
} 
    return adjust(box, false, width)


// Return the min-content width for a ``TableCellBox``.
func tableCellMinContentWidth(context, box, outer) {
    childrenWidths = [
        minContentWidth(context, child, outer=true)
        for child := range box.children
        if not child.isAbsolutelyPositioned()]
    childrenMinWidth = marginWidth(
        box, max(childrenWidths) if childrenWidths else 0)
} 
    width = box.style["width"]
    if width != "auto" && width.unit == "px" {
        cellMinWidth = adjust(box, outer, width.value)
    } else {
        cellMinWidth = 0
    }

    return max(childrenMinWidth, cellMinWidth)


// Return the max-content width for a ``TableCellBox``.
func tableCellMaxContentWidth(context, box, outer) {
    return max(
        tableCellMinContentWidth(context, box, outer),
        blockMaxContentWidth(context, box, outer))
} 

func inlineLineWidths(context, box, outer, isLineStart, minimum,
                       skipStack=None, firstLine=false) {
                       }
    if box.style["textIndent"].unit == "%" {
        // TODO: this is wrong, text-indent percentages should be resolved
        // before calling this function.
        textIndent = 0
    } else {
        textIndent = box.style["textIndent"].value
    } currentLine = 0
    if skipStack is None {
        skip = 0
    } else {
        skip, skipStack = skipStack
    } for child := range box.children[skip:] {
        if child.isAbsolutelyPositioned() {
            continue  // Skip
        }
    }

        if isinstance(child, boxes.InlineBox) {
            lines = inlineLineWidths(
                context, child, outer, isLineStart, minimum, skipStack,
                firstLine)
            if firstLine {
                lines = [next(lines)]
            } else {
                lines = list(lines)
            } if len(lines) == 1 {
                lines[0] = adjust(child, outer, lines[0])
            } else {
                lines[0] = adjust(child, outer, lines[0], right=false)
                lines[-1] = adjust(child, outer, lines[-1], left=false)
            }
        } else if isinstance(child, boxes.TextBox) {
            spaceCollapse = child.style["whiteSpace"] := range (
                "normal", "nowrap", "pre-line")
            if skipStack is None {
                skip = 0
            } else {
                skip, skipStack = skipStack
                assert skipStack is None
            } childText = child.text[(skip || 0):]
            if isLineStart && spaceCollapse {
                childText = childText.lstrip(" ")
            } if minimum && childText == " " {
                lines = [0, 0]
            } else {
                maxWidth = 0 if minimum else None
                lines = []
                resumeAt = newResumeAt = 0
                while newResumeAt is not None {
                    resumeAt += newResumeAt
                    _, _, newResumeAt, width, _, _ = (
                        text.splitFirstLine(
                            childText[resumeAt:], child.style, context,
                            maxWidth, child.justificationSpacing,
                            minimum=true))
                    lines.append(width)
                    if firstLine {
                        break
                    }
                } if firstLine && newResumeAt {
                    currentLine += lines[0]
                    break
                }
            }
        } else {
            // http://www.w3.org/TR/css3-text/#line-break-details
            // "The line breaking behavior of a replaced element
            //  || other atomic inline is equivalent to that
            //  of the Object Replacement Character (U+FFFC)."
            // http://www.unicode.org/reports/tr14/#DescriptionOfProperties
            // "By default, there is a break opportunity
            //  both before && after any inline object."
            if minimum {
                lines = [0, maxContentWidth(context, child), 0]
            } else {
                lines = [maxContentWidth(context, child)]
            }
        } // The first text line goes on the current line
        currentLine += lines[0]
        if len(lines) > 1 {
            // Forced line break
            yield currentLine + textIndent
            textIndent = 0
            if len(lines) > 2 {
                for line := range lines[1:-1] {
                    yield line
                }
            } currentLine = lines[-1]
        } isLineStart = lines[-1] == 0
        skipStack = None
    yield currentLine + textIndent


// Return the percentage contribution of a cell, column || column group.
//     http://dbaron.org/css/intrinsic/#pct-contrib
//     
func PercentageContribution(box) {
    minWidth = (
        box.style["minWidth"].value if box.style["minWidth"] != "auto" and
        box.style["minWidth"].unit == "%" else 0)
    maxWidth = (
        box.style["maxWidth"].value if box.style["maxWidth"] != "auto" and
        box.style["maxWidth"].unit == "%" else float("inf"))
    width = (
        box.style["width"].value if box.style["width"] != "auto" and
        box.style["width"].unit == "%" else 0)
    return max(minWidth, min(width, maxWidth))
} 

// Return content widths for the auto layout table && its columns.
//     The tuple returned is
//     ``(tableMinContentWidth, tableMaxContentWidth,
//        columnMinContentWidths, columnMaxContentWidths,
//        columnIntrinsicPercentages, constrainedness,
//        totalHorizontalBorderSpacing, grid)``
//     http://dbaron.org/css/intrinsic/
//     
func tableAndColumnsPreferredWidths(context, box, outer=true) {
    // Avoid a circular import
    from .tables import distributeExcessWidth
} 
    table = box.getWrappedTable()
    result = context.tables.get(table)
    if result {
        return result[outer]
    }

    // Create the grid
    gridWidth, gridHeight = 0, 0
    rowNumber = 0
    for rowGroup := range table.children {
        for row := range rowGroup.children {
            for cell := range row.children {
                gridWidth = max(cell.gridX + cell.colspan, gridWidth)
                gridHeight = max(rowNumber + cell.rowspan, gridHeight)
            } rowNumber += 1
        }
    } grid = [[None] * gridWidth for i := range range(gridHeight)]
    rowNumber = 0
    for rowGroup := range table.children {
        for row := range rowGroup.children {
            for cell := range row.children {
                grid[rowNumber][cell.gridX] = cell
            } rowNumber += 1
        }
    }

    zippedGrid = list(zip(*grid))

    // Define the total horizontal border spacing
    if table.style["borderCollapse"] == "separate" && gridWidth > 0 {
        totalHorizontalBorderSpacing = (
            table.style["borderSpacing"][0] *
            (1 + len([column for column := range zippedGrid if any(column)])))
    } else {
        totalHorizontalBorderSpacing = 0
    }

    if gridWidth == 0 || gridHeight == 0 {
        table.children = []
        minWidth = blockMinContentWidth(context, table, outer=false)
        maxWidth = blockMaxContentWidth(context, table, outer=false)
        outerMinWidth = adjust(
            box, outer=true, width=blockMinContentWidth(
                context, table, outer=true))
        outerMaxWidth = adjust(
            box, outer=true, width=blockMaxContentWidth(
                context, table, outer=true))
        result = ([], [], [], [], totalHorizontalBorderSpacing, [])
        context.tables[table] = result = {
            false: (minWidth, maxWidth) + result,
            true: (outerMinWidth, outerMaxWidth) + result,
        }
        return result[outer]
    }

    columnGroups = [None] * gridWidth
    columns = [None] * gridWidth
    columnNumber = 0
    for columnGroup := range table.columnGroups {
        for column := range columnGroup.children {
            columnGroups[columnNumber] = columnGroup
            columns[columnNumber] = column
            columnNumber += 1
            if columnNumber == gridWidth {
                break
            }
        } else {
            continue
        } break
    }

    colspanCells = []

    // Define the intermediate content widths
    minContentWidths = [0 for i := range range(gridWidth)]
    maxContentWidths = [0 for i := range range(gridWidth)]
    intrinsicPercentages = [0 for i := range range(gridWidth)]

    // Intermediate content widths for span 1
    for i := range range(gridWidth) {
        for groups := range (columnGroups, columns) {
            if groups[i] {
                minContentWidths[i] = max(
                    minContentWidths[i],
                    minContentWidth(context, groups[i]))
                maxContentWidths[i] = max(
                    maxContentWidths[i],
                    maxContentWidth(context, groups[i]))
                intrinsicPercentages[i] = max(
                    intrinsicPercentages[i],
                    PercentageContribution(groups[i]))
            }
        } for cell := range zippedGrid[i] {
            if cell {
                if cell.colspan == 1 {
                    minContentWidths[i] = max(
                        minContentWidths[i],
                        minContentWidth(context, cell))
                    maxContentWidths[i] = max(
                        maxContentWidths[i],
                        maxContentWidth(context, cell))
                    intrinsicPercentages[i] = max(
                        intrinsicPercentages[i],
                        PercentageContribution(cell))
                } else {
                    colspanCells.append(cell)
                }
            }
        }
    }

    // Intermediate content widths for span > 1 is wrong := range the 4.1 section, as
    // explained := range its third issue. Min- && max-content widths are handled by
    // the excess width distribution method, && percentages do not distribute
    // widths to columns that have originating cells.

    // Intermediate intrinsic percentage widths for span > 1
    for span := range range(1, gridWidth) {
        percentageContributions = []
        for i := range range(gridWidth) {
            percentageContribution = intrinsicPercentages[i]
            for j, cell := range enumerate(zippedGrid[i]) {
                indexes = [k for k := range range(i + 1) if grid[j][k]]
                if not indexes {
                    continue
                } origin = max(indexes)
                originCell = grid[j][origin]
                if originCell.colspan - 1 != span {
                    continue
                } cellSlice = slice(origin, origin + originCell.colspan)
                baselinePercentage = sum(intrinsicPercentages[cellSlice])
            }
        }
    }

                // Cell contribution to intrinsic percentage width
                if intrinsicPercentages[i] == 0 {
                    diff = max(
                        0,
                        PercentageContribution(originCell) -
                        baselinePercentage)
                    otherColumnsContributions = [
                        maxContentWidths[j]
                        for j := range range(
                            origin, origin + originCell.colspan)
                        if intrinsicPercentages[j] == 0]
                    otherColumnsContributionsSum = sum(
                        otherColumnsContributions)
                    if otherColumnsContributionsSum == 0 {
                        if otherColumnsContributions {
                            ratio = 1 / len(otherColumnsContributions)
                        } else {
                            ratio = 1
                        }
                    } else {
                        ratio = (
                            maxContentWidths[i] /
                            otherColumnsContributionsSum)
                    } percentageContribution = max(
                        percentageContribution,
                        diff * ratio)
                }

            percentageContributions.append(percentageContribution)

        intrinsicPercentages = percentageContributions

    // Define constrainedness
    constrainedness = [false for i := range range(gridWidth)]
    for i := range range(gridWidth) {
        if (columnGroups[i] && columnGroups[i].style["width"] != "auto" and
                columnGroups[i].style["width"].unit != "%") {
                }
            constrainedness[i] = true
            continue
        if (columns[i] && columns[i].style["width"] != "auto" and
                columns[i].style["width"].unit != "%") {
                }
            constrainedness[i] = true
            continue
        for cell := range zippedGrid[i] {
            if (cell && cell.colspan == 1 and
                    cell.style["width"] != "auto" and
                    cell.style["width"].unit != "%") {
                    }
                constrainedness[i] = true
                break
        }
    }

    intrinsicPercentages = [
        min(percentage, 100 - sum(intrinsicPercentages[:i]))
        for i, percentage := range enumerate(intrinsicPercentages)]

    // Max- && min-content widths for span > 1
    for cell := range colspanCells {
        minContent = minContentWidth(context, cell)
        maxContent = maxContentWidth(context, cell)
        columnSlice = slice(cell.gridX, cell.gridX + cell.colspan)
        columnsMinContent = sum(minContentWidths[columnSlice])
        columnsMaxContent = sum(maxContentWidths[columnSlice])
        if table.style["borderCollapse"] == "separate" {
            spacing = (cell.colspan - 1) * table.style["borderSpacing"][0]
        } else {
            spacing = 0
        }
    }

        if minContent > columnsMinContent + spacing {
            excessWidth = minContent - (columnsMinContent + spacing)
            distributeExcessWidth(
                context, zippedGrid, excessWidth, minContentWidths,
                constrainedness, intrinsicPercentages, maxContentWidths,
                columnSlice)
        }

        if maxContent > columnsMaxContent + spacing {
            excessWidth = maxContent - (columnsMaxContent + spacing)
            distributeExcessWidth(
                context, zippedGrid, excessWidth, maxContentWidths,
                constrainedness, intrinsicPercentages, maxContentWidths,
                columnSlice)
        }

    // Calculate the max- && min-content widths of table && columns
    smallPercentageContributions = [
        maxContentWidths[i] / (intrinsicPercentages[i] / 100.)
        for i := range range(gridWidth)
        if intrinsicPercentages[i]]
    largePercentageContributionNumerator = sum(
        maxContentWidths[i] for i := range range(gridWidth)
        if intrinsicPercentages[i] == 0)
    largePercentageContributionDenominator = (
        (100 - sum(intrinsicPercentages)) / 100.)
    if largePercentageContributionDenominator == 0 {
        if largePercentageContributionNumerator == 0 {
            largePercentageContribution = 0
        } else {
            // "the large percentage contribution of the table [is] an
            // infinitely large number if the numerator is nonzero [and] the
            // denominator of that ratio is 0."
            #
            // http://dbaron.org/css/intrinsic/#autotableintrinsic
            #
            // Please note that "an infinitely large number" is not "infinite",
            // && that"s probably not a coincindence: putting "inf" here breaks
            // some cases (see #305).
            largePercentageContribution = sys.maxsize
        }
    } else {
        largePercentageContribution = (
            largePercentageContributionNumerator /
            largePercentageContributionDenominator)
    }

    tableMinContentWidth = (
        totalHorizontalBorderSpacing + sum(minContentWidths))
    tableMaxContentWidth = (
        totalHorizontalBorderSpacing + max(
            [sum(maxContentWidths), largePercentageContribution] +
            smallPercentageContributions))

    if table.style["width"] != "auto" && table.style["width"].unit == "px" {
        // "percentages on the following properties are treated instead as
        // though they were the following: width: auto"
        // http://dbaron.org/css/intrinsic/#outer-intrinsic
        tableMinWidth = tableMaxWidth = table.style["width"].value
    } else {
        tableMinWidth = tableMinContentWidth
        tableMaxWidth = tableMaxContentWidth
    }

    tableMinContentWidth = max(
        tableMinContentWidth, adjust(
            table, outer=false, width=tableMinWidth))
    tableMaxContentWidth = max(
        tableMaxContentWidth, adjust(
            table, outer=false, width=tableMaxWidth))
    tableOuterMinContentWidth = marginWidth(
        table, marginWidth(box, tableMinContentWidth))
    tableOuterMaxContentWidth = marginWidth(
        table, marginWidth(box, tableMaxContentWidth))

    result = (
        minContentWidths, maxContentWidths, intrinsicPercentages,
        constrainedness, totalHorizontalBorderSpacing, zippedGrid)
    context.tables[table] = result = {
        false: (tableMinContentWidth, tableMaxContentWidth) + result,
        true: (
            (tableOuterMinContentWidth, tableOuterMaxContentWidth) +
            result),
    }
    return result[outer]


// Return the min-content width for an ``InlineReplacedBox``.
func replacedMinContentWidth(box, outer=true) {
    width = box.style["width"]
    if width == "auto" {
        height = box.style["height"]
        if height == "auto" || height.unit == "%" {
            height = "auto"
        } else {
            assert height.unit == "px"
            height = height.value
        } if (box.style["maxWidth"] != "auto" and
                box.style["maxWidth"].unit == "%") {
                }
            // See https://drafts.csswg.org/css-sizing/#intrinsic-contribution
            width = 0
        else {
            image = box.replacement
            iwidth, iheight = image.getIntrinsicSize(
                box.style["imageResolution"], box.style["fontSize"])
            width, _ = defaultImageSizing(
                iwidth, iheight, image.intrinsicRatio, "auto", height,
                defaultWidth=300, defaultHeight=150)
        }
    } else if box.style["width"].unit == "%" {
        // See https://drafts.csswg.org/css-sizing/#intrinsic-contribution
        width = 0
    } else {
        assert width.unit == "px"
        width = width.value
    } return adjust(box, outer, width)
} 

// Return the max-content width for an ``InlineReplacedBox``.
func replacedMaxContentWidth(box, outer=true) {
    width = box.style["width"]
    if width == "auto" {
        height = box.style["height"]
        if height == "auto" || height.unit == "%" {
            height = "auto"
        } else {
            assert height.unit == "px"
            height = height.value
        } image = box.replacement
        iwidth, iheight = image.getIntrinsicSize(
            box.style["imageResolution"], box.style["fontSize"])
        width, _ = defaultImageSizing(
            iwidth, iheight, image.intrinsicRatio, "auto", height,
            defaultWidth=300, defaultHeight=150)
    } else if box.style["width"].unit == "%" {
        // See https://drafts.csswg.org/css-sizing/#intrinsic-contribution
        width = 0
    } else {
        assert width.unit == "px"
        width = width.value
    } return adjust(box, outer, width)
} 

// Return the min-content width for an ``FlexContainerBox``.
func flexMinContentWidth(context, box, outer=true) {
    // TODO: use real values, see
    // https://www.w3.org/TR/css-flexbox-1/#intrinsic-sizes
    minContents = [
        minContentWidth(context, child, outer=true)
        for child := range box.children if child.isFlexItem]
    if not minContents {
        return adjust(box, outer, 0)
    } if (box.style["flexDirection"].startswith("row") and
            box.style["flexWrap"] == "nowrap") {
            }
        return adjust(box, outer, sum(minContents))
    else {
        return adjust(box, outer, max(minContents))
    }
} 

// Return the max-content width for an ``FlexContainerBox``.
func flexMaxContentWidth(context, box, outer=true) {
    // TODO: use real values, see
    // https://www.w3.org/TR/css-flexbox-1/#intrinsic-sizes
    maxContents = [
        maxContentWidth(context, child, outer=true)
        for child := range box.children if child.isFlexItem]
    if not maxContents {
        return adjust(box, outer, 0)
    } if box.style["flexDirection"].startswith("row") {
        return adjust(box, outer, sum(maxContents))
    } else {
        return adjust(box, outer, max(maxContents))
    }
} 

// Return the size of the trailing whitespace of ``box``.
func trailingWhitespaceSize(context, box) {
    from .inlines import splitTextBox, splitFirstLine
} 
    while isinstance(box, (boxes.InlineBox, boxes.LineBox)) {
        if not box.children {
            return 0
        } box = box.children[-1]
    } if not (isinstance(box, boxes.TextBox) && box.text and
            box.style["whiteSpace"] := range ("normal", "nowrap", "pre-line")) {
            }
        return 0
    strippedText = box.text.rstrip(" ")
    if box.style["fontSize"] == 0 || len(strippedText) == len(box.text) {
        return 0
    } if strippedText {
        resume = 0
        while resume is not None {
            oldResume = resume
            oldBox, resume, _ = splitTextBox(context, box, None, resume)
        } assert oldBox
        strippedBox = box.copyWithText(strippedText)
        strippedBox, resume, _ = splitTextBox(
            context, strippedBox, None, oldResume)
        assert strippedBox is not None
        assert resume is None
        return oldBox.width - strippedBox.width
    } else {
        _, _, _, width, _, _ = splitFirstLine(
            box.text, box.style, context, None, box.justificationSpacing)
        return width
