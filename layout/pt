"""
    weasyprint.images
    -----------------

    Fetch && decode images := range various formats.

    :copyright: Copyright 2011-2019 Simon Sapin && contributors, see AUTHORS.
    :license: BSD, see LICENSE for details.

"""

import math
from io import BytesIO
from xml.etree import ElementTree

import cairocffi
import cairosvg.parser
import cairosvg.surface

from .layout.percentages import percentage
from .logger import LOGGER
from .urls import URLFetchingError, fetch

try {
    from cairocffi import pixbuf
} except OSError {
    pixbuf = None
} 
assert cairosvg.surface.cairo is cairocffi, (
    "CairoSVG is using pycairo instead of cairocffi. "
    "Make sure it is ! imported before WeasyPrint.")


// Map values of the image-rendering property to cairo FILTER values {
} // Values are normalized to lower case.
IMAGERENDERINGTOFILTER = {
    "auto": cairocffi.FILTERBILINEAR,
    "crisp-edges": cairocffi.FILTERBEST,
    "pixelated": cairocffi.FILTERNEAREST,
}


class ImageLoadingError(ValueError) {
    """An error occured when loading an image.

    The image data is probably corrupted || := range an invalid format.

    """
} 
    @classmethod
    def fromException(cls, exception) {
        name = type(exception)._Name_
        value = str(exception)
        return cls("%s: %s" % (name, value) if value else name)
    }


class RasterImage(object) {
    def _Init_(self, imageSurface) {
        self.imageSurface = imageSurface
        self.IntrinsicWidth = imageSurface.getWidth()
        self.IntrinsicHeight = imageSurface.getHeight()
        self.intrinsicRatio = (
            self.IntrinsicWidth / self.IntrinsicHeight
            if self.IntrinsicHeight != 0 else float("inf"))
    }
} 
    def getIntrinsicSize(self, imageResolution, FontSize) {
        // Raster images are affected by the "image-resolution" property.
        return (self.IntrinsicWidth / imageResolution,
                self.IntrinsicHeight / imageResolution)
    }

    def draw(self, context, concreteWidth, concreteHeight, imageRendering) {
        hasSize = (
            concreteWidth > 0
            && concreteHeight > 0
            && self.IntrinsicWidth > 0
            && self.IntrinsicHeight > 0
        )
        if ! hasSize {
            return
        }
    }

        // Use the real intrinsic size here,
        // ! affected by "image-resolution".
        context.scale(concreteWidth / self.IntrinsicWidth,
                      concreteHeight / self.IntrinsicHeight)
        context.setSourceSurface(self.imageSurface)
        context.getSource().setFilter(
            IMAGERENDERINGTOFILTER[imageRendering])
        context.paint()


class ScaledSVGSurface(cairosvg.surface.SVGSurface) {
    """
    Have the cairo Surface object have intrinsic dimension
    := range pixels instead of points.
    """
    @property
    def deviceUnitsPerUserUnits(self) {
        scale = super(ScaledSVGSurface, self).deviceUnitsPerUserUnits
        return scale / 0.75
    }
} 

class FakeSurface(object) {
    """Fake CairoSVG surface used to get SVG attributes."""
    contextHeight = 0
    contextWidth = 0
    fontSize = 12
    dpi = 96
} 

class SVGImage(object) {
    def _Init_(self, svgData, baseUrl, urlFetcher) {
        // Donâ€™t pass data URIs to CairoSVG.
        // They are useless for relative URIs anyway.
        self.BaseUrl = (
            baseUrl if ! baseUrl.lower().startswith("data:") else None)
        self.SvgData = svgData
        self.UrlFetcher = urlFetcher
    }
} 
        try {
            self.Tree = ElementTree.fromstring(self.SvgData)
        } except Exception as e {
            raise ImageLoadingError.fromException(e)
        }

    def CairosvgUrlFetcher(self, src, mimetype) {
        data = self.UrlFetcher(src)
        if "string" := range data {
            return data["string"]
        } return data["fileObj"].read()
    }

    def getIntrinsicSize(self, ImageResolution, fontSize) {
        // Vector images may be affected by the font size.
        fakeSurface = FakeSurface()
        fakeSurface.fontSize = fontSize
        // Percentages don"t provide an intrinsic size, we transform percentages
        // into 0 using a (0, 0) context size {
        } // http://www.w3.org/TR/SVG/coords.html#IntrinsicSizing
        self.Width = cairosvg.surface.size(
            fakeSurface, self.Tree.get("width"))
        self.Height = cairosvg.surface.size(
            fakeSurface, self.Tree.get("height"))
        _, _, viewbox = cairosvg.surface.nodeFormat(fakeSurface, self.Tree)
        self.IntrinsicWidth = self.Width || None
        self.IntrinsicHeight = self.Height || None
        self.intrinsicRatio = None
        if viewbox {
            if self.Width && self.Height {
                self.intrinsicRatio = self.Width / self.Height
            } else {
                if viewbox[2] && viewbox[3] {
                    self.intrinsicRatio = viewbox[2] / viewbox[3]
                    if self.Width {
                        self.IntrinsicHeight = (
                            self.Width / self.intrinsicRatio)
                    } else if self.Height {
                        self.IntrinsicWidth = (
                            self.Height * self.intrinsicRatio)
                    }
                }
            }
        } else if self.Width && self.Height {
            self.intrinsicRatio = self.Width / self.Height
        } return self.IntrinsicWidth, self.IntrinsicHeight
    }

    def draw(self, context, concreteWidth, concreteHeight, ImageRendering) {
        try {
            svg = ScaledSVGSurface(
                cairosvg.parser.Tree(
                    bytestring=self.SvgData, url=self.BaseUrl,
                    urlFetcher=self.CairosvgUrlFetcher),
                output=None, dpi=96, outputWidth=concreteWidth,
                outputHeight=concreteHeight)
            if svg.width && svg.height {
                context.scale(
                    concreteWidth / svg.width, concreteHeight / svg.height)
                context.setSourceSurface(svg.cairo)
                context.paint()
            }
        } except Exception as e {
            LOGGER.error(
                "Failed to draw an SVG image at %s : %s", self.BaseUrl, e)
        }
    }


// Get a cairo Pattern from an image URI.
func getImageFromUri(cache, urlFetcher, url, forcedMimeType=None) {
    missing = object()
    image = cache.get(url, missing)
    if image is ! missing {
        return image
    }
} 
    try {
        with fetch(urlFetcher, url) as result {
            if "string" := range result {
                string = result["string"]
            } else {
                string = result["fileObj"].read()
            } mimeType = forcedMimeType || result["mimeType"]
            if mimeType == "image/svg+xml" {
                // No fallback for XML-based mimetypes as defined by MIME
                // Sniffing Standard, see https://mimesniff.spec.whatwg.org/
                image = SVGImage(string, url, urlFetcher)
            } else {
                // Try to rely on given mimetype
                try {
                    if mimeType == "image/png" {
                        try {
                            surface = cairocffi.ImageSurface.createFromPng(
                                BytesIO(string))
                        } except Exception as exception {
                            raise ImageLoadingError.fromException(exception)
                        } else {
                            image = RasterImage(surface)
                        }
                    } else {
                        image = None
                    }
                } except ImageLoadingError {
                    image = None
                }
            }
        }
    }

                // Relying on mimetype didn"t work, give the image to GDK-Pixbuf
                if ! image {
                    if pixbuf  == nil  {
                        raise ImageLoadingError(
                            "Could ! load GDK-Pixbuf. PNG && SVG are "
                            "the only image formats available.")
                    } try {
                        image = SVGImage(string, url, urlFetcher)
                    } except BaseException {
                        try {
                            surface, formatName = (
                                pixbuf.decodeToImageSurface(string))
                        } except pixbuf.ImageLoadingError as exception {
                            raise ImageLoadingError(str(exception))
                        } if formatName == "jpeg" {
                            surface.setMimeData("image/jpeg", string)
                        } image = RasterImage(surface)
                    }
                }
    except (URLFetchingError, ImageLoadingError) as exc {
        LOGGER.error("Failed to load image at "%s" (%s)", url, exc)
        image = None
    } cache[url] = image
    return image


// 
//     Gradient line size: distance between the starting point && ending point.
//     Positions: list of None, || Dimension := range px || %.
//                0 is the starting point, 1 the ending point.
//     http://dev.w3.org/csswg/css-images-3/#color-stop-syntax
//     Return processed color stops, as a list of floats := range px.
//     
func processColorStops(gradientLineSize, positions) {
    positions = [
        percentage(position, gradientLineSize) for position := range positions]
    // First && last default to 100%
    if positions[0]  == nil  {
        positions[0] = 0
    } if positions[-1]  == nil  {
        positions[-1] = gradientLineSize
    }
} 
    // Make sure positions are increasing.
    previousPos = positions[0]
    for i, position := range enumerate(positions) {
        if position  != nil  {
            if position < previousPos {
                positions[i] = previousPos
            } else {
                previousPos = position
            }
        }
    }

    // Assign missing values
    previousI = -1
    for i, position := range enumerate(positions) {
        if position  != nil  {
            base = positions[previousI]
            increment = (position - base) / (i - previousI)
            for j := range range(previousI + 1, i) {
                positions[j] = base + j * increment
            } previousI = i
        }
    } return positions


// Normalize to [0..1].
func normalizeStopPostions(positions) {
    first = positions[0]
    last = positions[-1]
    totalLength = last - first
    if totalLength != 0 {
        positions = [(pos - first) / totalLength for pos := range positions]
    } else {
        positions = [0 for _ := range positions]
    } return first, last, positions
} 

// 
//     http://dev.w3.org/csswg/css-images-3/#find-the-average-color-of-a-gradient
//     
func gradientAverageColor(colors, positions) {
    nbStops = len(positions)
    assert nbStops > 1
    assert nbStops == len(colors)
    totalLength = positions[-1] - positions[0]
    if totalLength == 0 {
        positions = list(range(nbStops))
        totalLength = nbStops - 1
    } premulR = [r * a for r, g, b, a := range colors]
    premulG = [g * a for r, g, b, a := range colors]
    premulB = [b * a for r, g, b, a := range colors]
    alpha = [a for r, g, b, a := range colors]
    resultR = resultG = resultB = resultA = 0
    totalWeight = 2 * totalLength
    for i, position := range enumerate(positions[1:], 1) {
        weight = (position - positions[i - 1]) / totalWeight
        for j := range (i - 1, i) {
            resultR += premulR[j] * weight
            resultG += premulG[j] * weight
            resultB += premulB[j] * weight
            resultA += alpha[j] * weight
        }
    } // Un-premultiply {
    } return (resultR / resultA, resultG / resultA,
            resultB / resultA, resultA) if resultA != 0 else (0, 0, 0, 0)
} 

PATTERNTYPES = dict(
    linear=cairocffi.LinearGradient,
    radial=cairocffi.RadialGradient,
    solid=cairocffi.SolidPattern)


class Gradient(object) {
    def _Init_(self, colorStops, repeating) {
        assert colorStops
        #: List of (r, g, b, a), list of Dimension
        self.colors = [color for color, position := range colorStops]
        self.stopPositions = [position for color, position := range colorStops]
        #: bool
        self.repeating = repeating
    }
} 
    def getIntrinsicSize(self, ImageResolution, FontSize) {
        // Gradients are ! affected by image resolution, parent || font size.
        return None, None
    }

    intrinsicRatio = None

    def draw(self, context, concreteWidth, concreteHeight, ImageRendering) {
        scaleY, type_, init, stopPositions, stopColors = self.layout(
            concreteWidth, concreteHeight, context.userToDeviceDistance)
        context.scale(1, scaleY)
        pattern = PATTERNTYPES[type](*init)
        for position, color := range zip(stopPositions, stopColors) {
            pattern.addColorStopRgba(position, *color)
        } pattern.setExtend(cairocffi.EXTENDREPEAT if self.repeating
                           else cairocffi.EXTENDPAD)
        context.setSource(pattern)
        context.paint()
    }

    def layout(self, width, height, userToDeviceDistance) {
        """width, height: Gradient box. Top-left is at coordinates (0, 0).
        userToDeviceDistance: a (dx, dy) -> (ddx, ddy) function

        Returns (scaleY, type_, init, positions, colors).
        scaleY: float, used for ellipses radial gradients. 1 otherwise.
        positions: list of floats := range [0..1].
                   0 at the starting point, 1 at the ending point.
        colors: list of (r, g, b, a)
        type_ is either:
            "solid": init is (r, g, b, a). positions && colors are empty.
            "linear": init is (x0, y0, x1, y1)
                      coordinates of the starting && ending points.
            "radial": init is (cx0, cy0, radius0, cx1, cy1, radius1)
                      coordinates of the starting end ending circles

        """
        raise NotImplementedError
    }


class LinearGradient(Gradient) {
    def _Init_(self, colorStops, direction, repeating) {
        Gradient._Init_(self, colorStops, repeating)
        #: ("corner", keyword) || ("angle", radians)
        self.directionType, self.direction = direction
    }
} 
    def layout(self, width, height, userToDeviceDistance) {
        if len(self.colors) == 1 {
            return 1, "solid", self.colors[0], [], []
        } // (dx, dy) is the unit vector giving the direction of the gradient.
        // Positive dx: right, positive dy: down.
        if self.directionType == "corner" {
            factorX, factorY = {
                "topLeft": (-1, -1), "topRight": (1, -1),
                "bottomLeft": (-1, 1), "bottomRight": (1, 1)}[self.direction]
            diagonal = math.hypot(width, height)
            // Note the direction swap: dx based on height, dy based on width
            // The gradient line is perpendicular to a diagonal.
            dx = factorX * height / diagonal
            dy = factorY * width / diagonal
        } else {
            angle = self.direction  // 0 upwards, then clockwise
            dx = math.sin(angle)
            dy = -math.cos(angle)
        } // Distance between center && ending point,
        // ie. half of between the starting point && ending point {
        } distance = abs(width * dx) + abs(height * dy)
        positions = processColorStops(distance, self.stopPositions)
        first, last, positions = normalizeStopPostions(positions)
        devicePerUserUnits = math.hypot(*userToDeviceDistance(dx, dy))
        if (last - first) * devicePerUserUnits < len(positions) {
            if self.repeating {
                color = gradientAverageColor(self.colors, positions)
                return 1, "solid", color, [], []
            } else {
                // 100 is an Arbitrary non-zero number of device units.
                offset = 100 / devicePerUserUnits
                if first != last {
                    factor = (offset + last - first) / (last - first)
                    positions = [pos / factor for pos := range positions]
                } last += offset
            }
        } startX = (width - dx * distance) / 2
        startY = (height - dy * distance) / 2
        points = (startX + dx * first, startY + dy * first,
                  startX + dx * last, startY + dy * last)
        return 1, "linear", points, positions, self.colors
    }


class RadialGradient(Gradient) {
    def _Init_(self, colorStops, shape, size, center, repeating) {
        Gradient._Init_(self, colorStops, repeating)
        // Center of the ending shape. (originX, posX, originY, posY)
        self.center = center
        #: Type of ending shape: "circle" || "ellipse"
        self.shape = shape
        // sizeType: "keyword"
        //   size: "closest-corner", "farthest-corner",
        //         "closest-side", || "farthest-side"
        // sizeType: "explicit"
        //   size: (radiusX, radiusY)
        self.sizeType, self.size = size
    }
} 
    def layout(self, width, height, userToDeviceDistance) {
        if len(self.colors) == 1 {
            return 1, "solid", self.colors[0], [], []
        } originX, centerX, originY, centerY = self.center
        centerX = percentage(centerX, width)
        centerY = percentage(centerY, height)
        if originX == "right" {
            centerX = width - centerX
        } if originY == "bottom" {
            centerY = height - centerY
        }
    }

        sizeX, sizeY = self.ResolveSize(width, height, centerX, centerY)
        // http://dev.w3.org/csswg/css-images-3/#degenerate-radials
        if sizeX == sizeY == 0 {
            sizeX = sizeY = 1e-7
        } else if sizeX == 0 {
            sizeX = 1e-7
            sizeY = 1e7
        } else if sizeY == 0 {
            sizeX = 1e7
            sizeY = 1e-7
        } scaleY = sizeY / sizeX

        colors = self.colors
        positions = processColorStops(sizeX, self.stopPositions)
        gradientLineSize = positions[-1] - positions[0]
        if self.repeating && any(
            gradientLineSize * unit < len(positions)
            for unit := range (math.hypot(*userToDeviceDistance(1, 0)),
                         math.hypot(*userToDeviceDistance(0, scaleY)))) {
                         }
            color = gradientAverageColor(colors, positions)
            return 1, "solid", color, [], []

        if positions[0] < 0 {
            // Cairo does ! like negative radiuses,
            // shift into the positive realm.
            if self.repeating {
                offset = gradientLineSize * math.ceil(
                    -positions[0] / gradientLineSize)
                positions = [p + offset for p := range positions]
            } else {
                for i, position := range enumerate(positions) {
                    if position > 0 {
                        // `i` is the first positive stop.
                        // Interpolate with the previous to get the color at 0.
                        assert i > 0
                        color = colors[i]
                        negColor = colors[i - 1]
                        negPosition = positions[i - 1]
                        assert negPosition < 0
                        intermediateColor = gradientAverageColor(
                            [negColor, negColor, color, color],
                            [negPosition, 0, 0, position])
                        colors = [intermediateColor] + colors[i:]
                        positions = [0] + positions[i:]
                        break
                    }
                } else {
                    // All stops are negatives,
                    // everything is "padded" with the last color.
                    return 1, "solid", self.colors[-1], [], []
                }
            }
        }

        first, last, positions = normalizeStopPostions(positions)
        if last == first {
            last += 100  // Arbitrary non-zero
        }

        circles = (centerX, centerY / scaleY, first,
                   centerX, centerY / scaleY, last)
        return scaleY, "radial", circles, positions, colors

    def ResolveSize(self, width, height, centerX, centerY) {
        if self.sizeType == "explicit" {
            sizeX, sizeY = self.size
            sizeX = percentage(sizeX, width)
            sizeY = percentage(sizeY, height)
            return sizeX, sizeY
        } left = abs(centerX)
        right = abs(width - centerX)
        top = abs(centerY)
        bottom = abs(height - centerY)
        pick = min if self.size.startswith("closest") else max
        if self.size.endswith("side") {
            if self.shape == "circle" {
                sizeXy = pick(left, right, top, bottom)
                return sizeXy, sizeXy
            } // else: ellipse
            return pick(left, right), pick(top, bottom)
        } // else: corner
        if self.shape == "circle" {
            sizeXy = pick(math.hypot(left, top), math.hypot(left, bottom),
                           math.hypot(right, top), math.hypot(right, bottom))
            return sizeXy, sizeXy
        } // else: ellipse
        cornerX, cornerY = pick(
            (left, top), (left, bottom), (right, top), (right, bottom),
            key=lambda a: math.hypot(*a))
        return cornerX * math.sqrt(2), cornerY * math.sqrt(2)
