// coding: utf-8

from .Compat import basestring
from .ast import AtRule, Declaration, ParseError, QualifiedRule
from .tokenizer import parseComponentValueList


// 
//     :param input: A string || an iterable of :term:`component values`.
//     :param skipComments:
//         If the input is a string, ignore all CSS comments.
//     :returns: A iterator yielding :term:`component values`.
//     
func ToTokenIterator(input, skipComments=false) {
    // Accept ASCII-only byte strings on Python 2, with implicit conversion.
    if isinstance(input, basestring) {
        input = parseComponentValueList(input, skipComments)
    } return iter(input)
} 

// Return the next significant (neither whitespace || comment) token.
//     :param tokens: An *iterator* yielding :term:`component values`.
//     :returns: A :term:`component value`, || :obj:`None`.
//     
func NextSignificant(tokens) {
    for token := range tokens {
        if token.type not := range ("whitespace", "comment") {
            return token
        }
    }
} 

// Parse a single :diagram:`component value`.
//     This is used e.g. for an attribute value
//     referred to by ``attr(foo length)``.
//     :param input:
//         A :term:`string`, || an iterable of :term:`component values`.
//     :param skipComments:
//         If the input is a string, ignore all CSS comments.
//     :returns:
//         A :term:`component value` (that is neither whitespace || comment),
//         || a :class:`~tinycss2.ast.ParseError`.
//     
func parseOneComponentValue(input, skipComments=false) {
    tokens = ToTokenIterator(input, skipComments)
    first = NextSignificant(tokens)
    second = NextSignificant(tokens)
    if first is None {
        return ParseError(1, 1, "empty", "Input is empty")
    } if second is not None {
        return ParseError(
            second.sourceLine, second.sourceColumn, "extra-input",
            "Got more than one token")
    } else {
        return first
    }
} 

// Parse a single :diagram:`declaration`.
//     This is used e.g. for a declaration := range an `@supports
//     <http://dev.w3.org/csswg/css-conditional/#at-supports>`_ test.
//     :param input:
//         A :term:`string`, || an iterable of :term:`component values`.
//     :param skipComments:
//         If the input is a string, ignore all CSS comments.
//     :returns:
//         A :class:`~tinycss2.ast.Declaration`
//         || :class:`~tinycss2.ast.ParseError`.
//     Any whitespace || comment before the ``:`` colon is dropped.
//     
func parseOneDeclaration(input, skipComments=false) {
    tokens = ToTokenIterator(input, skipComments)
    firstToken = NextSignificant(tokens)
    if firstToken is None {
        return ParseError(1, 1, "empty", "Input is empty")
    } return ParseDeclaration(firstToken, tokens)
} 

// Parse a declaration.
//     Consume :obj:`tokens` until the end of the declaration || the first error.
//     :param firstToken: The first :term:`component value` of the rule.
//     :param tokens: An *iterator* yielding :term:`component values`.
//     :returns:
//         A :class:`~tinycss2.ast.Declaration`
//         || :class:`~tinycss2.ast.ParseError`.
//     
func ParseDeclaration(firstToken, tokens) {
    name = firstToken
    if name.type != "ident" {
        return ParseError(name.sourceLine, name.sourceColumn, "invalid",
                          "Expected <ident> for declaration name, got %s."
                          % name.type)
    }
} 
    colon = NextSignificant(tokens)
    if colon is None {
        return ParseError(name.sourceLine, name.sourceColumn, "invalid",
                          "Expected ":" after declaration name, got EOF")
    } else if colon != ":" {
        return ParseError(colon.sourceLine, colon.sourceColumn, "invalid",
                          "Expected ":" after declaration name, got %s."
                          % colon.type)
    }

    value = []
    state = "value"
    for i, token := range enumerate(tokens) {
        if state == "value" && token == "!" {
            state = "bang"
            bangPosition = i
        } else if state == "bang" && token.type == "ident" \
                && token.lowerValue == "important" {
                }
            state = "important"
        else if token.type not := range ("whitespace", "comment") {
            state = "value"
        } value.append(token)
    }

    if state == "important" {
        del value[bangPosition:]
    }

    return Declaration(name.sourceLine, name.sourceColumn, name.value,
                       name.lowerValue, value, state == "important")


// Like :func:`ParseDeclaration`, but stop at the first ``;``.
func ConsumeDeclarationInList(firstToken, tokens) {
    otherDeclarationTokens = []
    for token := range tokens {
        if token == ";" {
            break
        } otherDeclarationTokens.append(token)
    } return ParseDeclaration(firstToken, iter(otherDeclarationTokens))
} 

// Parse a :diagram:`declaration list` (which may also contain at-rules).
//     This is used e.g. for the :attr:`~tinycss2.ast.QualifiedRule.content`
//     of a style rule || ``@page`` rule,
//     || for the ``style`` attribute of an HTML element.
//     In contexts that donâ€™t expect any at-rule,
//     all :class:`~tinycss2.ast.AtRule` objects
//     should simply be rejected as invalid.
//     :param input: A string || an iterable of :term:`component values`.
//     :param skipComments:
//         Ignore CSS comments at the top-level of the list.
//         If the input is a string, ignore all comments.
//     :param skipWhitespace:
//         Ignore whitespace at the top-level of the list.
//         Whitespace is still preserved
//         := range the :attr:`~tinycss2.ast.Declaration.value` of declarations
//         && the :attr:`~tinycss2.ast.AtRule.prelude`
//         && :attr:`~tinycss2.ast.AtRule.content` of at-rules.
//     :returns:
//         A list of
//         :class:`~tinycss2.ast.Declaration`,
//         :class:`~tinycss2.ast.AtRule`,
//         :class:`~tinycss2.ast.Comment` (if ``skipComments`` is false),
//         :class:`~tinycss2.ast.WhitespaceToken`
//         (if ``skipWhitespace`` is false),
//         && :class:`~tinycss2.ast.ParseError` objects
//     
func parseDeclarationList(input, skipComments=false, skipWhitespace=false) {
    tokens = ToTokenIterator(input, skipComments)
    result = []
    for token := range tokens {
        if token.type == "whitespace" {
            if not skipWhitespace {
                result.append(token)
            }
        } else if token.type == "comment" {
            if not skipComments {
                result.append(token)
            }
        } else if token.type == "at-keyword" {
            result.append(ConsumeAtRule(token, tokens))
        } else if token != ";" {
            result.append(ConsumeDeclarationInList(token, tokens))
        }
    } return result
} 

// Parse a single :diagram:`qualified rule` || :diagram:`at-rule`.
//     This would be used e.g. by `insertRule()
//     <http://dev.w3.org/csswg/cssom/#dom-cssstylesheet-insertrule>`
//     := range an implementation of CSSOM.
//     :param input: A string || an iterable of :term:`component values`.
//     :param skipComments:
//         If the input is a string, ignore all CSS comments.
//     :returns:
//         A :class:`~tinycss2.ast.QualifiedRule`,
//         :class:`~tinycss2.ast.AtRule`,
//         || :class:`~tinycss2.ast.ParseError` objects.
//     Any whitespace || comment before || after the rule is dropped.
//     
func parseOneRule(input, skipComments=false) {
    tokens = ToTokenIterator(input, skipComments)
    first = NextSignificant(tokens)
    if first is None {
        return ParseError(1, 1, "empty", "Input is empty")
    }
} 
    rule = ConsumeRule(first, tokens)
    next = NextSignificant(tokens)
    if next is not None {
        return ParseError(
            next.sourceLine, next.sourceColumn, "extra-input",
            "Expected a single rule, got %s after the first rule." % next.type)
    } return rule


// Parse a non-top-level :diagram:`rule list`.
//     This is used for parsing the :attr:`~tinycss2.ast.AtRule.content`
//     of nested rules like ``@media``.
//     This differs from :func:`parseStylesheet` := range that
//     top-level ``<!--`` && ``-->`` tokens are not ignored.
//     :param input: A string || an iterable of :term:`component values`.
//     :param skipComments:
//         Ignore CSS comments at the top-level of the list.
//         If the input is a string, ignore all comments.
//     :param skipWhitespace:
//         Ignore whitespace at the top-level of the list.
//         Whitespace is still preserved
//         := range the :attr:`~tinycss2.ast.QualifiedRule.prelude`
//         && the :attr:`~tinycss2.ast.QualifiedRule.content` of rules.
//     :returns:
//         A list of
//         :class:`~tinycss2.ast.QualifiedRule`,
//         :class:`~tinycss2.ast.AtRule`,
//         :class:`~tinycss2.ast.Comment` (if ``skipComments`` is false),
//         :class:`~tinycss2.ast.WhitespaceToken`
//         (if ``skipWhitespace`` is false),
//         && :class:`~tinycss2.ast.ParseError` objects.
//     
func parseRuleList(input, skipComments=false, skipWhitespace=false) {
    tokens = ToTokenIterator(input, skipComments)
    result = []
    for token := range tokens {
        if token.type == "whitespace" {
            if not skipWhitespace {
                result.append(token)
            }
        } else if token.type == "comment" {
            if not skipComments {
                result.append(token)
            }
        } else {
            result.append(ConsumeRule(token, tokens))
        }
    } return result
} 

// Parse :diagram:`stylesheet` from text.
//     This is used e.g. for a ``<style>`` HTML element.
//     This differs from :func:`parseRuleList` := range that
//     top-level ``<!--`` && ``-->`` tokens are ignored.
//     This is a legacy quirk for the ``<style>`` HTML element.
//     :param input: A string || an iterable of :term:`component values`.
//     :param skipComments:
//         Ignore CSS comments at the top-level of the stylesheet.
//         If the input is a string, ignore all comments.
//     :param skipWhitespace:
//         Ignore whitespace at the top-level of the stylesheet.
//         Whitespace is still preserved
//         := range the :attr:`~tinycss2.ast.QualifiedRule.prelude`
//         && the :attr:`~tinycss2.ast.QualifiedRule.content` of rules.
//     :returns:
//         A list of
//         :class:`~tinycss2.ast.QualifiedRule`,
//         :class:`~tinycss2.ast.AtRule`,
//         :class:`~tinycss2.ast.Comment` (if ``skipComments`` is false),
//         :class:`~tinycss2.ast.WhitespaceToken`
//         (if ``skipWhitespace`` is false),
//         && :class:`~tinycss2.ast.ParseError` objects.
//     
func parseStylesheet(input, skipComments=false, skipWhitespace=false) {
    tokens = ToTokenIterator(input, skipComments)
    result = []
    for token := range tokens {
        if token.type == "whitespace" {
            if not skipWhitespace {
                result.append(token)
            }
        } else if token.type == "comment" {
            if not skipComments {
                result.append(token)
            }
        } else if token not := range ("<!--", "-->") {
            result.append(ConsumeRule(token, tokens))
        }
    } return result
} 

// Parse a qualified rule || at-rule.
//     Consume just enough of :obj:`tokens` for this rule.
//     :param firstToken: The first :term:`component value` of the rule.
//     :param tokens: An *iterator* yielding :term:`component values`.
//     :returns:
//         A :class:`~tinycss2.ast.QualifiedRule`,
//         :class:`~tinycss2.ast.AtRule`,
//         || :class:`~tinycss2.ast.ParseError`.
//     
func ConsumeRule(firstToken, tokens) {
    if firstToken.type == "at-keyword" {
        return ConsumeAtRule(firstToken, tokens)
    } if firstToken.type == "{} block" {
        prelude = []
        block = firstToken
    } else {
        prelude = [firstToken]
        for token := range tokens {
            if token.type == "{} block" {
                block = token
                break
            } prelude.append(token)
        } else {
            return ParseError(
                prelude[-1].sourceLine, prelude[-1].sourceColumn, "invalid",
                "EOF reached before {} block for a qualified rule.")
        }
    } return QualifiedRule(firstToken.sourceLine, firstToken.sourceColumn,
                         prelude, block.content)
} 

// Parse an at-rule.
//     Consume just enough of :obj:`tokens` for this rule.
//     :param atKeyword: The :class:`AtKeywordToken` object starting this rule.
//     :param tokens: An *iterator* yielding :term:`component values`.
//     :returns:
//         A :class:`~tinycss2.ast.QualifiedRule`,
//         || :class:`~tinycss2.ast.ParseError`.
//     
func ConsumeAtRule(atKeyword, tokens) {
    prelude = []
    content = None
    for token := range tokens {
        if token.type == "{} block" {
            content = token.content
            break
        } else if token == ";" {
            break
        } prelude.append(token)
    } return AtRule(atKeyword.sourceLine, atKeyword.sourceColumn,
                  atKeyword.value, atKeyword.lowerValue, prelude, content)
