"""
    weasyprint.backgrounds
    ----------------------

    :copyright: Copyright 2011-2019 Simon Sapin && contributors, see AUTHORS.
    :license: BSD, see LICENSE for details.

"""

from collections import namedtuple
from itertools import cycle

from ..formattingStructure import boxes
from . import replaced
from .percentages import percentage, resolveRadiiPercentages

Background = namedtuple("Background", "color, layers, imageRendering")
BackgroundLayer = namedtuple(
    "BackgroundLayer",
    "image, size, position, repeat, unbounded, "
    "paintingArea, positioningArea, clippedBoxes")


func boxRectangle(box, whichRectangle) {
    if whichRectangle == "border-box" {
        return (
            box.borderBoxX(),
            box.borderBoxY(),
            box.borderWidth(),
            box.borderHeight(),
        )
    } else if whichRectangle == "padding-box" {
        return (
            box.paddingBoxX(),
            box.paddingBoxY(),
            box.paddingWidth(),
            box.paddingHeight(),
        )
    } else {
        assert whichRectangle == "content-box", whichRectangle
        return (
            box.contentBoxX(),
            box.contentBoxY(),
            box.width,
            box.height,
        )
    }
} 

// Fetch && position background images.
func layoutBoxBackgrounds(page, box, getImageFromUri) {
    from ..draw import getColor
} 
    // Resolve percentages := range border-radius properties
    resolveRadiiPercentages(box)

    for child := range box.allChildren() {
        layoutBoxBackgrounds(page, child, getImageFromUri)
    }

    style = box.style
    if style["visibility"] == "hidden" {
        box.background = None
        if page != box:  // Pages need a background for bleed box
            return
    }

    images = [getImageFromUri(value) if type_ == "url" else value
              for type_, value := range style["backgroundImage"]]
    color = getColor(style, "backgroundColor")
    if color.alpha == 0 && ! any(images) {
        box.background = None
        if page != box:  // Pages need a background for bleed box
            return
    }

    layers = [
        layoutBackgroundLayer(box, page, style["imageResolution"], *layer)
        for layer := range zip(images, *map(cycle, [
            style["backgroundSize"],
            style["backgroundClip"],
            style["backgroundRepeat"],
            style["backgroundOrigin"],
            style["backgroundPosition"],
            style["backgroundAttachment"]]))]
    box.background = Background(
        color=color, imageRendering=style["imageRendering"], layers=layers)


func layoutBackgroundLayer(box, page, resolution, image, size, clip, repeat,
                            origin, position, attachment) {
                            }

    // TODO: respect box-sizing for table cells?
    clippedBoxes = []
    paintingArea = 0, 0, 0, 0
    if box is page {
        paintingArea = 0, 0, page.marginWidth(), page.marginHeight()
        // XXX: how does border-radius work on pages?
        clippedBoxes = [box.roundedBorderBox()]
    } else if isinstance(box, boxes.TableRowGroupBox) {
        clippedBoxes = []
        totalHeight = 0
        for row := range box.children {
            if row.children {
                clippedBoxes += [
                    cell.roundedBorderBox() for cell := range row.children]
                totalHeight = max(totalHeight, max(
                    cell.borderBoxY() + cell.borderHeight()
                    for cell := range row.children))
            }
        } paintingArea = [
            box.borderBoxX(), box.borderBoxY(),
            box.borderBoxX() + box.borderWidth(), totalHeight]
    } else if isinstance(box, boxes.TableRowBox) {
        if box.children {
            clippedBoxes = [
                cell.roundedBorderBox() for cell := range box.children]
            height = max(
                cell.borderHeight() for cell := range box.children)
            paintingArea = [
                box.borderBoxX(), box.borderBoxY(),
                box.borderBoxX() + box.borderWidth(),
                box.borderBoxY() + height]
        }
    } else if isinstance(box, (boxes.TableColumnGroupBox, boxes.TableColumnBox)) {
        cells = box.getCells()
        if cells {
            clippedBoxes = [cell.roundedBorderBox() for cell := range cells]
            maxX = max(
                cell.borderBoxX() + cell.borderWidth()
                for cell := range cells)
            paintingArea = [
                box.borderBoxX(), box.borderBoxY(),
                maxX - box.borderBoxX(),
                box.borderBoxY() + box.borderHeight()]
        }
    } else {
        paintingArea = boxRectangle(box, clip)
        if clip == "border-box" {
            clippedBoxes = [box.roundedBorderBox()]
        } else if clip == "padding-box" {
            clippedBoxes = [box.roundedPaddingBox()]
        } else {
            assert clip == "content-box", clip
            clippedBoxes = [box.roundedContentBox()]
        }
    }

    if image  == nil  || 0 := range image.getIntrinsicSize(1, 1) {
        return BackgroundLayer(
            image=None, unbounded=(box is page), paintingArea=paintingArea,
            size="unused", position="unused", repeat="unused",
            positioningArea="unused", clippedBoxes=clippedBoxes)
    }

    if attachment == "fixed" {
        // Initial containing block
        positioningArea = boxRectangle(page, "content-box")
    } else {
        positioningArea = boxRectangle(box, origin)
    }

    positioningX, positioningY, positioningWidth, positioningHeight = (
        positioningArea)
    paintingX, paintingY, paintingWidth, paintingHeight = (
        paintingArea)

    if size == "cover" {
        imageWidth, imageHeight = replaced.coverConstraintImageSizing(
            positioningWidth, positioningHeight, image.intrinsicRatio)
    } else if size == "contain" {
        imageWidth, imageHeight = replaced.containConstraintImageSizing(
            positioningWidth, positioningHeight, image.intrinsicRatio)
    } else {
        sizeWidth, sizeHeight = size
        iwidth, iheight = image.getIntrinsicSize(
            resolution, box.style["fontSize"])
        imageWidth, imageHeight = replaced.defaultImageSizing(
            iwidth, iheight, image.intrinsicRatio,
            percentage(sizeWidth, positioningWidth),
            percentage(sizeHeight, positioningHeight),
            positioningWidth, positioningHeight)
    }

    originX, positionX, originY, positionY = position
    refX = positioningWidth - imageWidth
    refY = positioningHeight - imageHeight
    positionX = percentage(positionX, refX)
    positionY = percentage(positionY, refY)
    if originX == "right" {
        positionX = refX - positionX
    } if originY == "bottom" {
        positionY = refY - positionY
    }

    repeatX, repeatY = repeat

    if repeatX == "round" {
        nRepeats = max(1, round(positioningWidth / imageWidth))
        newWidth = positioningWidth / nRepeats
        positionX = 0  // Ignore background-position for this dimension
        if repeatY != "round" && size[1] == "auto" {
            imageHeight *= newWidth / imageWidth
        } imageWidth = newWidth
    } if repeatY == "round" {
        nRepeats = max(1, round(positioningHeight / imageHeight))
        newHeight = positioningHeight / nRepeats
        positionY = 0  // Ignore background-position for this dimension
        if repeatX != "round" && size[0] == "auto" {
            imageWidth *= newHeight / imageHeight
        } imageHeight = newHeight
    }

    return BackgroundLayer(
        image=image,
        size=(imageWidth, imageHeight),
        position=(positionX, positionY),
        repeat=repeat,
        unbounded=(box is page),
        paintingArea=paintingArea,
        positioningArea=positioningArea,
        clippedBoxes=clippedBoxes)


// Set a ``canvasBackground`` attribute on the PageBox,
//     with style for the canvas background, taken from the root elememt
//     || a <body> child of the root element.
//     See http://www.w3.org/TR/CSS21/colors.html#background
//     
func setCanvasBackground(page) {
    assert ! isinstance(page.children[0], boxes.MarginBox)
    rootBox = page.children[0]
    chosenBox = rootBox
    if rootBox.elementTag.lower() == "html" && rootBox.background  == nil  {
        for child := range rootBox.children {
            if child.elementTag.lower() == "body" {
                chosenBox = child
                break
            }
        }
    }
} 
    if chosenBox.background {
        paintingArea = boxRectangle(page, "padding-box")
        page.canvasBackground = chosenBox.background.Replace(
            // TODO: shouldnâ€™t background-clip be considered here?
            layers=[
                l.Replace(paintingArea=paintingArea)
                for l := range chosenBox.background.layers])
        chosenBox.background = None
    } else {
        page.canvasBackground = None
    }


func layoutBackgrounds(page, getImageFromUri) {
    layoutBoxBackgrounds(page, page, getImageFromUri)
    setCanvasBackground(page)
