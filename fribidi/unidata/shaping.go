package main

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"strings"
)

/* We do not support surrogates yet */
const FRIBIDI_UNICODE_CHARS = 0x110000

// read UnicodeData to build a Go lookup table

var table [FRIBIDI_UNICODE_CHARS][4]rune

func fillTable() (rune, rune, error) {
	// initialisation
	for c := range table {
		for i := range table[c] {
			table[c][i] = rune(c)
		}
	}

	b, err := ioutil.ReadFile("UnicodeData.txt")
	if err != nil {
		return 0, 0, err
	}
	var (
		min rune = FRIBIDI_UNICODE_CHARS
		max rune
	)
	for _, l := range bytes.Split(b, []byte{'\n'}) {
		line := string(bytes.TrimSpace(l))
		if line == "" || line[0] == '#' { // reading header or comment
			continue
		}
		chunks := strings.Split(line, ";")
		// we are looking for <...> XXXX
		if len(chunks) < 6 || chunks[5] == "" || chunks[5][0] != '<' {
			continue
		}
		var (
			c        rune
			tag      string
			unshaped rune
		)
		_, err = fmt.Sscanf(chunks[5], "%s %04x", &tag, &unshaped)
		if err != nil {
			return 0, 0, fmt.Errorf("invalid line %s: %s", line, err)
		}
		_, err = fmt.Sscanf(chunks[0], "%04x", &c)
		if err != nil {
			return 0, 0, fmt.Errorf("invalid line %s: %s", line, err)
		}
		if c >= FRIBIDI_UNICODE_CHARS || unshaped >= FRIBIDI_UNICODE_CHARS {
			return 0, 0, fmt.Errorf("invalid line %s: too high rune value", line)
		}

		if shape := isShape(tag); shape >= 0 {
			table[unshaped][shape] = c
			if unshaped < min {
				min = unshaped
			}
			if unshaped > max {
				max = unshaped
			}
		}
	}
	return min, max, nil
}

var arabicShapingTags = [...]string{
	"<isolated>",
	"<final>",
	"<initial>",
	"<medial>",
}

func isShape(s string) int {
	for i, tag := range arabicShapingTags {
		if tag == s {
			return i
		}
	}
	return -1
}

const accesFunc = `
func %s(r rune, shape uint8) rune {
	if r < %d || r > %d {
		return r
	}
	return %s[r-%d][shape]
}
`

func genTable(out io.Writer, minshaped, maxshaped rune) error {
	if maxshaped < minshaped {
		return errors.New("error: no shaping pair found, something wrong with reading input")
	}

	const (
		table_name = "arShap"
		macro_name = "getArabicShapePres"
	)

	_, err := fmt.Fprintln(out, "package fribidi\n\n // auto-generated by fribidi/unidata/shaping.go from UnicodeData.txt DO NOT EDIT")
	if err != nil {
		return err
	}
	_, err = fmt.Fprintf(out, "// required memory: %d KB\n", (maxshaped-minshaped+1)*4*4/1000)
	if err != nil {
		return err
	}

	_, err = fmt.Fprintf(out, "var %s = [...][4]rune{\n", table_name)
	if err != nil {
		return err
	}
	for c := minshaped; c <= maxshaped; c++ {
		_, err = fmt.Fprintf(out, "%#v,\n", table[c])
		if err != nil {
			return err
		}
	}
	_, err = fmt.Fprintf(out, "}\n\n")
	if err != nil {
		return err
	}

	_, err = fmt.Fprintf(out, accesFunc, macro_name, minshaped, maxshaped, table_name, minshaped)
	return err
}

func main() {
	min, max, err := fillTable()
	if err != nil {
		log.Fatal(err)
	}
	outfile := "../arabic_table.go"
	f, err := os.Create(outfile)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()
	err = genTable(f, min, max)
	if err != nil {
		log.Fatal(err)
	}
	err = exec.Command("goimports", "-w", outfile).Run()
	if err != nil {
		log.Fatal("can't format: ", err)
	}
	fmt.Println("Done.")
}
