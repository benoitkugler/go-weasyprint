package boxes

import (
	"fmt"

	pr "github.com/benoitkugler/go-weasyprint/style/properties"
	"github.com/benoitkugler/go-weasyprint/style/tree"
)

// autogenerated from source_box.py

func (TableRowGroupBox) IsProperChild(parent Box) bool {
	switch parent.(type) {
	case *TableBox, *InlineTableBox:
		return true
	default:
		return false
	}
}

func (TableRowBox) IsProperChild(parent Box) bool {
	switch parent.(type) {
	case *TableBox, *InlineTableBox, *TableRowGroupBox:
		return true
	default:
		return false
	}
}

func (TableColumnGroupBox) IsProperChild(parent Box) bool {
	switch parent.(type) {
	case *TableBox, *InlineTableBox:
		return true
	default:
		return false
	}
}

func (TableColumnBox) IsProperChild(parent Box) bool {
	switch parent.(type) {
	case *TableBox, *InlineTableBox, *TableColumnGroupBox:
		return true
	default:
		return false
	}
}

func (TableCaptionBox) IsProperChild(parent Box) bool {
	switch parent.(type) {
	case *TableBox, *InlineTableBox:
		return true
	default:
		return false
	}
}

// A box that has children.
type InstanceParentBox interface {
	isParentBox()
}

// A box that participates in an block formatting context.
// An element with a ``display`` value of ``block``, ``list-item`` or
// ``table`` generates a block-level box.
type InstanceBlockLevelBox interface {
	isBlockLevelBox()
}

// A box that contains only block-level boxes or only line boxes.
// A box that either contains only block-level boxes or establishes an inline
// formatting context and thus contains only line boxes.
// A non-replaced element with a ``display`` value of ``block``,
// ``list-item``, ``inline-block`` or 'table-cell' generates a block container
// box.
type InstanceBlockContainerBox interface {
	isBlockContainerBox()
	isParentBox()
}

// A block-level box that is also a block container.
// A non-replaced element with a ``display`` value of ``block``, ``list-item``
// generates a block box.
type InstanceBlockBox interface {
	isBlockBox()
	isParentBox()
	isBlockContainerBox()
	isBlockLevelBox()
}

func (b *BlockBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b BlockBox) Copy() Box { return &b }

func (b BlockBox) String() string {
	return fmt.Sprintf("<BlockBox %s>", b.BoxFields.elementTag)
}

func BlockBoxAnonymousFrom(parent Box, children []Box) *BlockBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewBlockBox(parent.Box().elementTag, style, children)
	return &out

}

func (t typeBlockBox) IsInstance(box Box) bool {
	_, is := box.(InstanceBlockBox)
	return is
}

type typeBlockBox struct{}

func (t typeBlockBox) AnonymousFrom(parent Box, children []Box) Box {
	return BlockBoxAnonymousFrom(parent, children)
}

// A box that represents a line in an inline formatting context.
// Can only contain inline-level boxes.
// In early stages of building the box tree a single line box contains many
// consecutive inline boxes. Later, during layout phase, each line boxes will
// be split into multiple line boxes, one for each actual line.
type InstanceLineBox interface {
	isLineBox()
	isParentBox()
}

func (b *LineBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b LineBox) Copy() Box { return &b }

func (b LineBox) String() string {
	return fmt.Sprintf("<LineBox %s>", b.BoxFields.elementTag)
}

func (t typeLineBox) IsInstance(box Box) bool {
	_, is := box.(InstanceLineBox)
	return is
}

type typeLineBox struct{}

func (t typeLineBox) AnonymousFrom(parent Box, children []Box) Box {
	return LineBoxAnonymousFrom(parent, children)
}

// A box that participates in an inline formatting context.
// An inline-level box that is not an inline box is said to be "atomic". Such
// boxes are inline blocks, replaced elements and inline tables.
// An element with a ``display`` value of ``inline``, ``inline-table``, or
// ``inline-block`` generates an inline-level box.
type InstanceInlineLevelBox interface {
	isInlineLevelBox()
}

// An inline box with inline children.
// A box that participates in an inline formatting context and whose content
// also participates in that inline formatting context.
// A non-replaced element with a ``display`` value of ``inline`` generates an
// inline box.
type InstanceInlineBox interface {
	isInlineBox()
	isParentBox()
	isInlineLevelBox()
}

func (b *InlineBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b InlineBox) Copy() Box { return &b }

func (b InlineBox) String() string {
	return fmt.Sprintf("<InlineBox %s>", b.BoxFields.elementTag)
}

func InlineBoxAnonymousFrom(parent Box, children []Box) *InlineBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewInlineBox(parent.Box().elementTag, style, children)
	return &out

}

func (t typeInlineBox) IsInstance(box Box) bool {
	_, is := box.(InstanceInlineBox)
	return is
}

type typeInlineBox struct{}

func (t typeInlineBox) AnonymousFrom(parent Box, children []Box) Box {
	return InlineBoxAnonymousFrom(parent, children)
}

// A box that contains only text and has no box children.
// Any text in the document ends up in a text box. What CSS calls "anonymous
// inline boxes" are also text boxes.
type InstanceTextBox interface {
	isTextBox()
	isInlineLevelBox()
}

func (b *TextBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b TextBox) Copy() Box { return &b }

func (b TextBox) String() string {
	return fmt.Sprintf("<TextBox %s>", b.BoxFields.elementTag)
}

func TextBoxAnonymousFrom(parent Box, text string) *TextBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewTextBox(parent.Box().elementTag, style, text)
	return &out

}

// An atomic box in an inline formatting context.
// This inline-level box cannot be split for line breaks.
type InstanceAtomicInlineLevelBox interface {
	isAtomicInlineLevelBox()
	isInlineLevelBox()
}

// A box that is both inline-level and a block container.
// It behaves as inline on the outside and as a block on the inside.
// A non-replaced element with a 'display' value of 'inline-block' generates
// an inline-block box.
type InstanceInlineBlockBox interface {
	isInlineBlockBox()
	isParentBox()
	isBlockContainerBox()
	isAtomicInlineLevelBox()
	isInlineLevelBox()
}

func (b *InlineBlockBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b InlineBlockBox) Copy() Box { return &b }

func (b InlineBlockBox) String() string {
	return fmt.Sprintf("<InlineBlockBox %s>", b.BoxFields.elementTag)
}

func InlineBlockBoxAnonymousFrom(parent Box, children []Box) *InlineBlockBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewInlineBlockBox(parent.Box().elementTag, style, children)
	return &out

}

func (t typeInlineBlockBox) IsInstance(box Box) bool {
	_, is := box.(InstanceInlineBlockBox)
	return is
}

type typeInlineBlockBox struct{}

func (t typeInlineBlockBox) AnonymousFrom(parent Box, children []Box) Box {
	return InlineBlockBoxAnonymousFrom(parent, children)
}

// A box whose content is replaced.
// For example, ``<img>`` are replaced: their content is rendered externally
// and is opaque from CSSâ€™s point of view.
type InstanceReplacedBox interface {
	isReplacedBox()
}

// A box that is both replaced and block-level.
// A replaced element with a ``display`` value of ``block``, ``liste-item`` or
// ``table`` generates a block-level replaced box.
type InstanceBlockReplacedBox interface {
	isBlockReplacedBox()
	isBlockLevelBox()
	isReplacedBox()
}

func (b *BlockReplacedBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b BlockReplacedBox) Copy() Box { return &b }

func (b BlockReplacedBox) String() string {
	return fmt.Sprintf("<BlockReplacedBox %s>", b.BoxFields.elementTag)
}

func BlockReplacedBoxAnonymousFrom(parent Box, replacement pr.Image) *BlockReplacedBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewBlockReplacedBox(parent.Box().elementTag, style, replacement)
	return &out

}

// A box that is both replaced and inline-level.
// A replaced element with a ``display`` value of ``inline``,
// ``inline-table``, or ``inline-block`` generates an inline-level replaced
// box.
type InstanceInlineReplacedBox interface {
	isInlineReplacedBox()
	isAtomicInlineLevelBox()
	isReplacedBox()
	isInlineLevelBox()
}

func (b *InlineReplacedBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b InlineReplacedBox) Copy() Box { return &b }

func (b InlineReplacedBox) String() string {
	return fmt.Sprintf("<InlineReplacedBox %s>", b.BoxFields.elementTag)
}

func InlineReplacedBoxAnonymousFrom(parent Box, replacement pr.Image) *InlineReplacedBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewInlineReplacedBox(parent.Box().elementTag, style, replacement)
	return &out

}

// Box for elements with ``display: table``
type InstanceTableBox interface {
	isTableBox()
	isParentBox()
	isBlockLevelBox()
}

func (b *TableBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b TableBox) Copy() Box { return &b }

func (b TableBox) String() string {
	return fmt.Sprintf("<TableBox %s>", b.BoxFields.elementTag)
}

func TableBoxAnonymousFrom(parent Box, children []Box) *TableBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewTableBox(parent.Box().elementTag, style, children)
	return &out

}

func (t typeTableBox) IsInstance(box Box) bool {
	_, is := box.(InstanceTableBox)
	return is
}

type typeTableBox struct{}

func (t typeTableBox) AnonymousFrom(parent Box, children []Box) Box {
	return TableBoxAnonymousFrom(parent, children)
}

// Box for elements with ``display: inline-table``
type InstanceInlineTableBox interface {
	isInlineTableBox()
	isParentBox()
	isTableBox()
	isBlockLevelBox()
}

func (b *InlineTableBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b InlineTableBox) Copy() Box { return &b }

func (b InlineTableBox) String() string {
	return fmt.Sprintf("<InlineTableBox %s>", b.BoxFields.elementTag)
}

func InlineTableBoxAnonymousFrom(parent Box, children []Box) *InlineTableBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewInlineTableBox(parent.Box().elementTag, style, children)
	return &out

}

func (t typeInlineTableBox) IsInstance(box Box) bool {
	_, is := box.(InstanceInlineTableBox)
	return is
}

type typeInlineTableBox struct{}

func (t typeInlineTableBox) AnonymousFrom(parent Box, children []Box) Box {
	return InlineTableBoxAnonymousFrom(parent, children)
}

// Box for elements with ``display: table-row-group``
type InstanceTableRowGroupBox interface {
	isTableRowGroupBox()
	isParentBox()
}

func (b *TableRowGroupBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b TableRowGroupBox) Copy() Box { return &b }

func (b TableRowGroupBox) String() string {
	return fmt.Sprintf("<TableRowGroupBox %s>", b.BoxFields.elementTag)
}

func TableRowGroupBoxAnonymousFrom(parent Box, children []Box) *TableRowGroupBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewTableRowGroupBox(parent.Box().elementTag, style, children)
	return &out

}

func (t typeTableRowGroupBox) IsInstance(box Box) bool {
	_, is := box.(InstanceTableRowGroupBox)
	return is
}

type typeTableRowGroupBox struct{}

func (t typeTableRowGroupBox) AnonymousFrom(parent Box, children []Box) Box {
	return TableRowGroupBoxAnonymousFrom(parent, children)
}

// Box for elements with ``display: table-row``
type InstanceTableRowBox interface {
	isTableRowBox()
	isParentBox()
}

func (b *TableRowBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b TableRowBox) Copy() Box { return &b }

func (b TableRowBox) String() string {
	return fmt.Sprintf("<TableRowBox %s>", b.BoxFields.elementTag)
}

func TableRowBoxAnonymousFrom(parent Box, children []Box) *TableRowBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewTableRowBox(parent.Box().elementTag, style, children)
	return &out

}

func (t typeTableRowBox) IsInstance(box Box) bool {
	_, is := box.(InstanceTableRowBox)
	return is
}

type typeTableRowBox struct{}

func (t typeTableRowBox) AnonymousFrom(parent Box, children []Box) Box {
	return TableRowBoxAnonymousFrom(parent, children)
}

// Box for elements with ``display: table-column-group``
type InstanceTableColumnGroupBox interface {
	isTableColumnGroupBox()
	isParentBox()
}

func (b *TableColumnGroupBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b TableColumnGroupBox) Copy() Box { return &b }

func (b TableColumnGroupBox) String() string {
	return fmt.Sprintf("<TableColumnGroupBox %s>", b.BoxFields.elementTag)
}

func TableColumnGroupBoxAnonymousFrom(parent Box, children []Box) *TableColumnGroupBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewTableColumnGroupBox(parent.Box().elementTag, style, children)
	return &out

}

func (t typeTableColumnGroupBox) IsInstance(box Box) bool {
	_, is := box.(InstanceTableColumnGroupBox)
	return is
}

type typeTableColumnGroupBox struct{}

func (t typeTableColumnGroupBox) AnonymousFrom(parent Box, children []Box) Box {
	return TableColumnGroupBoxAnonymousFrom(parent, children)
}

// Box for elements with ``display: table-column``
type InstanceTableColumnBox interface {
	isTableColumnBox()
	isParentBox()
}

func (b *TableColumnBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b TableColumnBox) Copy() Box { return &b }

func (b TableColumnBox) String() string {
	return fmt.Sprintf("<TableColumnBox %s>", b.BoxFields.elementTag)
}

func TableColumnBoxAnonymousFrom(parent Box, children []Box) *TableColumnBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewTableColumnBox(parent.Box().elementTag, style, children)
	return &out

}

func (t typeTableColumnBox) IsInstance(box Box) bool {
	_, is := box.(InstanceTableColumnBox)
	return is
}

type typeTableColumnBox struct{}

func (t typeTableColumnBox) AnonymousFrom(parent Box, children []Box) Box {
	return TableColumnBoxAnonymousFrom(parent, children)
}

// Box for elements with ``display: table-cell``
type InstanceTableCellBox interface {
	isTableCellBox()
	isParentBox()
	isBlockContainerBox()
}

func (b *TableCellBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b TableCellBox) Copy() Box { return &b }

func (b TableCellBox) String() string {
	return fmt.Sprintf("<TableCellBox %s>", b.BoxFields.elementTag)
}

func TableCellBoxAnonymousFrom(parent Box, children []Box) *TableCellBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewTableCellBox(parent.Box().elementTag, style, children)
	return &out

}

func (t typeTableCellBox) IsInstance(box Box) bool {
	_, is := box.(InstanceTableCellBox)
	return is
}

type typeTableCellBox struct{}

func (t typeTableCellBox) AnonymousFrom(parent Box, children []Box) Box {
	return TableCellBoxAnonymousFrom(parent, children)
}

// Box for elements with ``display: table-caption``
type InstanceTableCaptionBox interface {
	isTableCaptionBox()
	isBlockBox()
	isParentBox()
	isBlockContainerBox()
	isBlockLevelBox()
}

func (b *TableCaptionBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b TableCaptionBox) Copy() Box { return &b }

func (b TableCaptionBox) String() string {
	return fmt.Sprintf("<TableCaptionBox %s>", b.BoxFields.elementTag)
}

func TableCaptionBoxAnonymousFrom(parent Box, children []Box) *TableCaptionBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewTableCaptionBox(parent.Box().elementTag, style, children)
	return &out

}

func (t typeTableCaptionBox) IsInstance(box Box) bool {
	_, is := box.(InstanceTableCaptionBox)
	return is
}

type typeTableCaptionBox struct{}

func (t typeTableCaptionBox) AnonymousFrom(parent Box, children []Box) Box {
	return TableCaptionBoxAnonymousFrom(parent, children)
}

// Box for a page.
// Initially the whole document will be in the box for the root element.
// During layout a new page box is created after every page break.
type InstancePageBox interface {
	isPageBox()
	isParentBox()
}

func (b *PageBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b PageBox) Copy() Box { return &b }

// Box in page margins, as defined in CSS3 Paged Media
type InstanceMarginBox interface {
	isMarginBox()
	isParentBox()
	isBlockContainerBox()
}

func (b *MarginBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b MarginBox) Copy() Box { return &b }

// A box that contains only flex-items.
type InstanceFlexContainerBox interface {
	isFlexContainerBox()
	isParentBox()
}

// A box that is both block-level and a flex container.
// It behaves as block on the outside and as a flex container on the inside.
type InstanceFlexBox interface {
	isFlexBox()
	isParentBox()
	isFlexContainerBox()
	isBlockLevelBox()
}

func (b *FlexBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b FlexBox) Copy() Box { return &b }

func (b FlexBox) String() string {
	return fmt.Sprintf("<FlexBox %s>", b.BoxFields.elementTag)
}

func FlexBoxAnonymousFrom(parent Box, children []Box) *FlexBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewFlexBox(parent.Box().elementTag, style, children)
	return &out

}

func (t typeFlexBox) IsInstance(box Box) bool {
	_, is := box.(InstanceFlexBox)
	return is
}

type typeFlexBox struct{}

func (t typeFlexBox) AnonymousFrom(parent Box, children []Box) Box {
	return FlexBoxAnonymousFrom(parent, children)
}

// A box that is both inline-level and a flex container.
// It behaves as inline on the outside and as a flex container on the inside.
type InstanceInlineFlexBox interface {
	isInlineFlexBox()
	isParentBox()
	isFlexContainerBox()
	isInlineLevelBox()
}

func (b *InlineFlexBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b InlineFlexBox) Copy() Box { return &b }

func (b InlineFlexBox) String() string {
	return fmt.Sprintf("<InlineFlexBox %s>", b.BoxFields.elementTag)
}

func InlineFlexBoxAnonymousFrom(parent Box, children []Box) *InlineFlexBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewInlineFlexBox(parent.Box().elementTag, style, children)
	return &out

}

func (t typeInlineFlexBox) IsInstance(box Box) bool {
	_, is := box.(InstanceInlineFlexBox)
	return is
}

type typeInlineFlexBox struct{}

func (t typeInlineFlexBox) AnonymousFrom(parent Box, children []Box) Box {
	return InlineFlexBoxAnonymousFrom(parent, children)
}

var (
	TypeBlockBox            BoxType = typeBlockBox{}
	TypeLineBox             BoxType = typeLineBox{}
	TypeInlineBox           BoxType = typeInlineBox{}
	TypeInlineBlockBox      BoxType = typeInlineBlockBox{}
	TypeTableBox            BoxType = typeTableBox{}
	TypeInlineTableBox      BoxType = typeInlineTableBox{}
	TypeTableRowGroupBox    BoxType = typeTableRowGroupBox{}
	TypeTableRowBox         BoxType = typeTableRowBox{}
	TypeTableColumnGroupBox BoxType = typeTableColumnGroupBox{}
	TypeTableColumnBox      BoxType = typeTableColumnBox{}
	TypeTableCellBox        BoxType = typeTableCellBox{}
	TypeTableCaptionBox     BoxType = typeTableCaptionBox{}
	TypeFlexBox             BoxType = typeFlexBox{}
	TypeInlineFlexBox       BoxType = typeInlineFlexBox{}
)
