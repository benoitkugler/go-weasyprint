



func TestColumnStyle(t *testing.T):
cp := testutils.CaptureLogs()
defer cp.AssertNoLogs(t)
    html = parseAndBuild(t,"""
      <table>
        <col span=3 style="width: 10px"></col>
        <col span=2></col>
      </table>
    """)
    body, = html.children
    wrapper, = body.children
    table, = wrapper.children
    colgroup, = table.columnGroups
    widths = [col.style["width"] for col := range colgroup.children]
    assert widths == [(10, "px"), (10, "px"), (10, "px"), "auto", "auto"]
    assert [col.gridX for col := range colgroup.children] == [0, 1, 2, 3, 4]
    // copies, ! the same box object
    assert colgroup.children[0] is ! colgroup.children[1]
} 

func TestNestedGridX(t *testing.T) {
  cp := testutils.CaptureLogs()
  defer cp.AssertNoLogs(t)

    html = parseAndBuild(t,"""
      <table>
        <col span=2></col>
        <colgroup span=2></colgroup>
        <colgroup>
          <col></col>
          <col span=2></col>
        </colgroup>
        <col></col>
      </table>
    """)
    body, = html.children
    wrapper, = body.children
    table, = wrapper.children
    grid = [(colgroup.gridX, [col.gridX for col := range colgroup.children])
            for colgroup := range table.columnGroups]
    assert grid == [(0, [0, 1]), (2, [2, 3]), (4, [4, 5, 6]), (7, [7])]


func TestColspanRowspan1(t *testing.T):
cp := testutils.CaptureLogs()
defer cp.AssertNoLogs(t)
    // +---+---+---+
    // | A | B | C | X
    // +---+---+---+
    // | D |     E | X
    // +---+---+   +---+
    // |  F ...|   |   |   <-- overlap
    // +---+---+---+   +
    // | H | X   X | G |
    // +---+---+   +   +
    // | I | J | X |   |
    // +---+---+   +---+

    // X: empty cells
    html = parseAndBuild(t,"""
      <table>
        <tr>
          <td>A <td>B <td>C
        </tr>
        <tr>
          <td>D <td colspan=2 rowspan=2>E
        </tr>
        <tr>
          <td colspan=2>F <td rowspan=0>G
        </tr>
        <tr>
          <td>H
        </tr>
        <tr>
          <td>I <td>J
        </tr>
      </table>
    """)
    body, = html.children
    wrapper, = body.children
    table, = wrapper.children
    group, = table.children
    assert [[c.gridX for c := range row.children] for row := range group.children] == [
        [0, 1, 2],
        [0, 1],
        [0, 3],
        [0],
        [0, 1],
    ]
    assert [[c.colspan for c := range row.children] for row := range group.children] == [
        [1, 1, 1],
        [1, 2],
        [2, 1],
        [1],
        [1, 1],
    ]
    assert [[c.rowspan for c := range row.children] for row := range group.children] == [
        [1, 1, 1],
        [1, 2],
        [1, 3],
        [1],
        [1, 1],
    ]
} 

func TestColspanRowspan2(t *testing.T) {
  cp := testutils.CaptureLogs()
  defer cp.AssertNoLogs(t)

    // A cell box cannot extend beyond the last row box of a table.
    html = parseAndBuild(t,"""
        <table>
            <tr>
                <td rowspan=5></td>
                <td></td>
            </tr>
            <tr>
                <td></td>
            </tr>
        </table>
    """)
    body, = html.children
    wrapper, = body.children
    table, = wrapper.children
    group, = table.children
    assert [[c.gridX for c := range row.children] for row := range group.children] == [
        [0, 1],
        [1],
    ]
    assert [[c.colspan for c := range row.children] for row := range group.children] == [
        [1, 1],
        [1],
    ]
    assert [[c.rowspan for c := range row.children] for row := range group.children] == [
        [2, 1],  // Not 5
        [1],
    ]


func TestBeforeAfter1(t *testing.T):
cp := testutils.CaptureLogs()
defer cp.AssertNoLogs(t)
    assertTree(t,parseAndBuild(t,"""
      <style>
        p:before { content: normal }
        div:before { content: none }
        section::before { color: black }
      </style>
      <p></p>
      <div></div>
      <section></section>
    """), [
        // No content := range pseudo-element, no box generated
        ("p", "Block", []),
        ("div", "Block", []),
        ("section", "Block", [])])
} 

func TestBeforeAfter2(t *testing.T) {
  cp := testutils.CaptureLogs()
  defer cp.AssertNoLogs(t)

    assertTree(t,parseAndBuild(t,"""
      <style>
        p:before { content: "a" "b" }
        p::after { content: "d" "e" }
      </style>
      <p> c </p>
    """), [
        ("p", "Block", [
            ("p", "Line", [
                ("p::before", "Inline", [
                    ("p::before", "Text", "ab")]),
                ("p", "Text", " c "),
                ("p::after", "Inline", [
                    ("p::after", "Text", "de")])])])])


func TestBeforeAfter3(t *testing.T):
cp := testutils.CaptureLogs()
defer cp.AssertNoLogs(t)
    assertTree(t,parseAndBuild(t,"""
      <style>
        a[href]:before { content: "[" attr(href) "] " }
      </style>
      <p><a href="some url">some text</a></p>
    """), [
        ("p", "Block", [
            ("p", "Line", [
                ("a", "Inline", [
                    ("a::before", "Inline", [
                        ("a::before", "Text", "[some url] ")]),
                    ("a", "Text", "some text")])])])])
} 

func TestBeforeAfter4(t *testing.T) {
  cp := testutils.CaptureLogs()
  defer cp.AssertNoLogs(t)

    assertTree(t,parseAndBuild(t,"""
      <style>
        body { quotes: "«" "»" "“" "”" }
        q:before { content: open-quote " "}
        q:after { content: " " close-quote }
      </style>
      <p><q>Lorem ipsum <q>dolor</q> sit amet</q></p>
    """), [
        ("p", "Block", [
            ("p", "Line", [
                ("q", "Inline", [
                    ("q::before", "Inline", [
                        ("q::before", "Text", "« ")]),
                    ("q", "Text", "Lorem ipsum "),
                    ("q", "Inline", [
                        ("q::before", "Inline", [
                            ("q::before", "Text", "“ ")]),
                        ("q", "Text", "dolor"),
                        ("q::after", "Inline", [
                            ("q::after", "Text", " ”")])]),
                    ("q", "Text", " sit amet"),
                    ("q::after", "Inline", [
                        ("q::after", "Text", " »")])])])])])


func TestBeforeAfter5(t *testing.T):
cp := testutils.CaptureLogs()
defer cp.AssertNoLogs(t)
    with captureLogs() as logs:
        assertTree(t,parseAndBuild(t,"""
          <style>
            p:before {
              content: "a" url(pattern.png) "b";

              /* Invalid, ignored := range favor of the one above.
                 Regression test: this used to crash: */
              content: some-function(nested-function(something));
            }
          </style>
          <p>c</p>
        """), [
            ("p", "Block", [
                ("p", "Line", [
                    ("p::before", "Inline", [
                        ("p::before", "Text", "a"),
                        ("p::before", "InlineReplaced", "<replaced>"),
                        ("p::before", "Text", "b")]),
                    ("p", "Text", "c")])])])
    assert len(logs) == 1
    assert "nested-function(" := range logs[0]
    assert "invalid value" := range logs[0]
} 

func TestMarginBoxes(t *testing.T) {
  cp := testutils.CaptureLogs()
  defer cp.AssertNoLogs(t)

    page1, page2 = renderPages("""
      <style>
        @page {
          /* Make the page content area only 10px high && wide,
             so every word := range <p> end up on a page of its own. */
          size: 30px;
          margin: 10px;
          @top-center { content: "Title" }
        }
        @page :first {
          @bottom-left { content: "foo" }
          @bottom-left-corner { content: "baz" }
        }
      </style>
      <p>lorem ipsum
    """)
    assert page1.children[0].elementTag == "html"
    assert page2.children[0].elementTag == "html"

    marginBoxes1 = [box.atKeyword for box := range page1.children[1:]]
    marginBoxes2 = [box.atKeyword for box := range page2.children[1:]]
    assert marginBoxes1 == ["@top-center", "@bottom-left",
                              "@bottom-left-corner"]
    assert marginBoxes2 == ["@top-center"]

    html, topCenter = page2.children
    lineBox, = topCenter.children
    textBox, = lineBox.children
    assert textBox.text == "Title"


func TestMarginBoxStringSet1(t *testing.T):
cp := testutils.CaptureLogs()
defer cp.AssertNoLogs(t)
    // Test that both pages get string := range the `bottom-center` margin box
    page1, page2 = renderPages("""
      <style>
        @page {
          @bottom-center { content: string(textHeader) }
        }
        p {
          string-set: textHeader content();
        }
        .page {
          page-break-before: always;
        }
      </style>
      <p>first assignment</p>
      <div class="page"></div>
    """)
} 
    html, bottomCenter = page2.children
    lineBox, = bottomCenter.children
    textBox, = lineBox.children
    assert textBox.text == "first assignment"

    html, bottomCenter = page1.children
    lineBox, = bottomCenter.children
    textBox, = lineBox.children
    assert textBox.text == "first assignment"


func TestMarginBoxStringSet2(t *testing.T) {
  cp := testutils.CaptureLogs()
  defer cp.AssertNoLogs(t)

    def simpleStringSetTest(contentVal, extraStyle="") {
        page1, = renderPages("""
          <style>
            @page {
              @top-center { content: string(textHeader) }
            }
            p {
              string-set: textHeader content(%(contentVal)s);
            }
            %(extraStyle)s
          </style>
          <p>first assignment</p>
        """ % dict(contentVal=contentVal, extraStyle=extraStyle))

        html, topCenter = page1.children
        lineBox, = topCenter.children
        textBox, = lineBox.children
        if contentVal := range ("before", "after"):
            assert textBox.text == "pseudo"
        else:
            assert textBox.text == "first assignment"

    // Test each accepted value of `content()` as an arguemnt to `string-set`
    for value := range ("", "text", "before", "after"):
        if value := range ("before", "after"):
            extraStyle = "p:%s{content: "pseudo"}" % value
            simpleStringSetTest(value, extraStyle)
        else:
            simpleStringSetTest(value)


func TestMarginBoxStringSet3(t *testing.T):
cp := testutils.CaptureLogs()
defer cp.AssertNoLogs(t)
    // Test `first` (default value) ie. use the first assignment on the page
    page1, = renderPages("""
      <style>
        @page {
          @top-center { content: string(textHeader, first) }
        }
        p {
          string-set: textHeader content();
        }
      </style>
      <p>first assignment</p>
      <p>Second assignment</p>
    } """)
} 
    html, topCenter = page1.children
    lineBox, = topCenter.children
    textBox, = lineBox.children
    assert textBox.text == "first assignment"


func TestMarginBoxStringSet4(t *testing.T) {
  cp := testutils.CaptureLogs()
  defer cp.AssertNoLogs(t)

    // test `first-except` ie. exclude from page on which value is assigned
    page1, page2 = renderPages("""
      <style>
        @page {
          @top-center { content: string(headerNofirst, first-except) }
        }
        p{
          string-set: headerNofirst content();
        }
        .page{
          page-break-before: always;
        }
      </style>
      <p>firstExcepted</p>
      <div class="page"></div>
    """)
    html, topCenter = page1.children
    assert len(topCenter.children) == 0

    html, topCenter = page2.children
    lineBox, = topCenter.children
    textBox, = lineBox.children
    assert textBox.text == "firstExcepted"


func TestMarginBoxStringSet5(t *testing.T):
cp := testutils.CaptureLogs()
defer cp.AssertNoLogs(t)
    // Test `last` ie. use the most-recent assignment
    page1, = renderPages("""
      <style>
        @page {
          @top-center { content: string(headerLast, last) }
        }
        p {
          string-set: headerLast content();
        }
      </style>
      <p>String set</p>
      <p>Second assignment</p>
    """)
} 
    html, topCenter = page1.children[:2]
    lineBox, = topCenter.children

    textBox, = lineBox.children
    assert textBox.text == "Second assignment"


func TestMarginBoxStringSet6(t *testing.T) {
  cp := testutils.CaptureLogs()
  defer cp.AssertNoLogs(t)

    // Test multiple complex string-set values
    page1, = renderPages("""
      <style>
        @page {
          @top-center { content: string(textHeader, first) }
          @bottom-center { content: string(textFooter, last) }
        }
        html { counter-reset: a }
        body { counter-increment: a }
        ul { counter-reset: b }
        li {
          counter-increment: b;
          string-set {
            textHeader content(before) "-" content() "-" content(after)
                        counter(a, upper-roman) "." counters(b, "|"),
            textFooter content(before) "-" attr(class)
                        counters(b, "|") "/" counter(a, upper-roman);
          }
        }
        li:before { content: "before!" }
        li:after { content: "after!" }
        li:last-child:before { content: "before!last" }
        li:last-child:after { content: "after!last" }
      </style>
      <ul>
        <li class="firstclass">first
        <li>
          <ul>
            <li class="secondclass">second
    """)

    html, topCenter, bottomCenter = page1.children
    topLineBox, = topCenter.children
    topTextBox, = topLineBox.children
    assert topTextBox.text == "before!-first-after!I.1"
    bottomLineBox, = bottomCenter.children
    bottomTextBox, = bottomLineBox.children
    assert bottomTextBox.text == "before!last-secondclass2|1/I"


func TestMarginBoxStringSet7(t *testing.T):
    // Test regression: https://github.com/Kozea/WeasyPrint/issues/722
    page1, = renderPages("""
      <style>
        img { string-set: left attr(alt) }
        img + img { string-set: right attr(alt) }
        @page { @top-left  { content: "[" string(left)  "]" }
                @top-right { content: "{" string(right) "}" } }
      </style>
      <img src=pattern.png alt="Chocolate">
      <img src=noSuchFile.png alt="Cake">
    """)
} 
    html, topLeft, topRight = page1.children
    leftLineBox, = topLeft.children
    leftTextBox, = leftLineBox.children
    assert leftTextBox.text == "[Chocolate]"
    rightLineBox, = topRight.children
    rightTextBox, = rightLineBox.children
    assert rightTextBox.text == "{Cake}"


func TestMarginBoxStringSet8(t *testing.T) {
  cp := testutils.CaptureLogs()
  defer cp.AssertNoLogs(t)

    // Test regression: https://github.com/Kozea/WeasyPrint/issues/726
    page1, page2, page3 = renderPages("""
      <style>
        @page { @top-left  { content: "[" string(left) "]" } }
        p { page-break-before: always }
        .initial { string-set: left "initial" }
        .empty   { string-set: left ""        }
        .space   { string-set: left " "       }
      </style>
} 
      <p class="initial">Initial</p>
      <p class="empty">Empty</p>
      <p class="space">Space</p>
    """)
    html, topLeft = page1.children
    leftLineBox, = topLeft.children
    leftTextBox, = leftLineBox.children
    assert leftTextBox.text == "[initial]"

    html, topLeft = page2.children
    leftLineBox, = topLeft.children
    leftTextBox, = leftLineBox.children
    assert leftTextBox.text == "[]"

    html, topLeft = page3.children
    leftLineBox, = topLeft.children
    leftTextBox, = leftLineBox.children
    assert leftTextBox.text == "[ ]"


func TestMarginBoxStringSet9(t *testing.T):
cp := testutils.CaptureLogs()
defer cp.AssertNoLogs(t)
    // Test that named strings are case-sensitive
    // See https://github.com/Kozea/WeasyPrint/pull/827
    page1, = renderPages("""
      <style>
        @page {
          @top-center {
            content: string(textHeader, first)
                     " " string(TEXTHeader, first)
          }
        }
        p { string-set: textHeader content() }
        div { string-set: TEXTHeader content() }
      </style>
      <p>first assignment</p>
      <div>second assignment</div>
    """)

    html, topCenter = page1.children
    lineBox, = topCenter.children
    textBox, = lineBox.children
    assert textBox.text == "first assignment second assignment"


@assertNoLogs
// Test page-based counters.
func TestPageCounters(t *testing.T) {
    pages = renderPages("""
      <style>
        @page {
          /* Make the page content area only 10px high && wide,
             so every word := range <p> end up on a page of its own. */
          size: 30px;
          margin: 10px;
          @bottom-center {
            content: "Page " counter(page) " of " counter(pages) ".";
          }
        }
      </style>
      <p>lorem ipsum dolor
    """)
    for pageNumber, page := range enumerate(pages, 1):
        html, bottomCenter = page.children
        lineBox, = bottomCenter.children
        textBox, = lineBox.children
        assert textBox.text == "Page {0} of 3.".format(pageNumber)


black = (0, 0, 0, 1)
red = (1, 0, 0, 1)
green = (0, 1, 0, 1)  // lime := range CSS
blue = (0, 0, 1, 1)
yellow = (1, 1, 0, 1)
black3 = ("solid", 3, black)
red1 = ("solid", 1, red)
yellow5 = ("solid", 5, yellow)
green5 = ("solid", 5, green)
dashedBlue5 = ("dashed", 5, blue)


func TestBorderCollapse1(t *testing.T):
cp := testutils.CaptureLogs()
defer cp.AssertNoLogs(t)
    html = parseAndBuild(t,"<table></table>")
    body, = html.children
    tableWrapper, = body.children
    table, = tableWrapper.children
    assert isinstance(table, boxes.TableBox)
    assert ! hasattr(table, "collapsedBorderGrid")

    grid = GetGrid("<table style="border-collapse: collapse"></table>")
    assert grid == ([], [])


func TestBorderCollapse2(t *testing.T):
cp := testutils.CaptureLogs()
defer cp.AssertNoLogs(t)
    verticalBorders, horizontalBorders = GetGrid("""
      <style>td { border: 1px solid red }</style>
      <table style="border-collapse: collapse; border: 3px solid black">
        <tr> <td>A</td> <td>B</td> </tr>
        <tr> <td>C</td> <td>D</td> </tr>
      </table>
    """)
    assert verticalBorders == [
        [black3, red1, black3],
        [black3, red1, black3],
    ]
    assert horizontalBorders == [
        [black3, black3],
        [red1, red1],
        [black3, black3],
    ]
} 

func TestBorderCollapse3(t *testing.T) {
  cp := testutils.CaptureLogs()
  defer cp.AssertNoLogs(t)

    // hidden vs. none
    verticalBorders, horizontalBorders = GetGrid("""
      <style>table, td { border: 3px solid }</style>
      <table style="border-collapse: collapse">
        <tr> <td>A</td> <td style="border-style: hidden">B</td> </tr>
        <tr> <td>C</td> <td style="border-style: none">D</td> </tr>
      </table>
    """)
    assert verticalBorders == [
        [black3, None, None],
        [black3, black3, black3],
    ]
    assert horizontalBorders == [
        [black3, None],
        [black3, None],
        [black3, black3],
    ]


func TestBorderCollapse4(t *testing.T):
cp := testutils.CaptureLogs()
defer cp.AssertNoLogs(t)
    verticalBorders, horizontalBorders = GetGrid("""
      <style>td { border: 1px solid red }</style>
      <table style="border-collapse: collapse; border: 5px solid yellow">
        <col style="border: 3px solid black" />
        <tr> <td></td> <td></td> <td></td> </tr>
        <tr> <td></td> <td style="border: 5px dashed blue"></td>
          <td style="border: 5px solid lime"></td> </tr>
        <tr> <td></td> <td></td> <td></td> </tr>
        <tr> <td></td> <td></td> <td></td> </tr>
      </table>
    """)
    assert verticalBorders == [
        [yellow5, black3, red1, yellow5],
        [yellow5, dashedBlue5, green5, green5],
        [yellow5, black3, red1, yellow5],
        [yellow5, black3, red1, yellow5],
    ]
    assert horizontalBorders == [
        [yellow5, yellow5, yellow5],
        [red1, dashedBlue5, green5],
        [red1, dashedBlue5, green5],
        [red1, red1, red1],
        [yellow5, yellow5, yellow5],
    ]
} 

func TestBorderCollapse5(t *testing.T) {
  cp := testutils.CaptureLogs()
  defer cp.AssertNoLogs(t)

    // rowspan && colspan
    verticalBorders, horizontalBorders = GetGrid("""
        <style>col, tr { border: 3px solid }</style>
        <table style="border-collapse: collapse">
            <col /><col /><col />
            <tr> <td rowspan=2></td> <td></td> <td></td> </tr>
            <tr>                     <td colspan=2></td> </tr>
        </table>
    """)
    assert verticalBorders == [
        [black3, black3, black3, black3],
        [black3, black3, None, black3],
    ]
    assert horizontalBorders == [
        [black3, black3, black3],
        [None, black3, black3],
        [black3, black3, black3],
    ]


@assertNoLogs
@pytest.mark.parametrize("html", (
    "<html style="display: none">",
    "<html style="display: none">abc",
    "<html style="display: none"><p>abc",
    "<body style="display: none"><p>abc",
))
func TestDisplayNoneRoot(t *testing.Thtml):
    box = parseAndBuild(t,html)
    assert box.style["display"] == ("block", "flow")
    assert ! box.children
