package boxes

import (
	"fmt"

	"github.com/benoitkugler/go-weasyprint/images"
	"github.com/benoitkugler/go-weasyprint/style/tree"
)

// autogenerated from source_box.py

func (TableRowGroupBox) IsProperChild(parent Box) bool {
	switch parent.(type) {
	case *TableBox, *InlineTableBox:
		return true
	default:
		return false
	}
}

func (TableRowBox) IsProperChild(parent Box) bool {
	switch parent.(type) {
	case *TableBox, *InlineTableBox, *TableRowGroupBox:
		return true
	default:
		return false
	}
}

func (TableColumnGroupBox) IsProperChild(parent Box) bool {
	switch parent.(type) {
	case *TableBox, *InlineTableBox:
		return true
	default:
		return false
	}
}

func (TableColumnBox) IsProperChild(parent Box) bool {
	switch parent.(type) {
	case *TableBox, *InlineTableBox, *TableColumnGroupBox:
		return true
	default:
		return false
	}
}

func (TableCaptionBox) IsProperChild(parent Box) bool {
	switch parent.(type) {
	case *TableBox, *InlineTableBox:
		return true
	default:
		return false
	}
}

// A box that has children.
type instanceParentBox interface {
	isParentBox()
	isBox()
}

func IsParentBox(box Box) bool {
	_, is := box.(instanceParentBox)
	return is
}

// A box that participates in an block formatting context.
// An element with a ``display`` value of ``block``, ``list-item`` or
// ``table`` generates a block-level box.
type instanceBlockLevelBox interface {
	isBlockLevelBox()
	isBox()
}

func IsBlockLevelBox(box Box) bool {
	_, is := box.(instanceBlockLevelBox)
	return is
}

// A box that contains only block-level boxes or only line boxes.
// A box that either contains only block-level boxes or establishes an inline
// formatting context and thus contains only line boxes.
// A non-replaced element with a ``display`` value of ``block``,
// ``list-item``, ``inline-block`` or 'table-cell' generates a block container
// box.
type instanceBlockContainerBox interface {
	isBlockContainerBox()
	isBox()
	isParentBox()
}

func IsBlockContainerBox(box Box) bool {
	_, is := box.(instanceBlockContainerBox)
	return is
}

// A block-level box that is also a block container.
// A non-replaced element with a ``display`` value of ``block``, ``list-item``
// generates a block box.
type instanceBlockBox interface {
	instanceBlockContainerBox
	instanceBlockLevelBox
	// isBlockBox()
	// isBlockLevelBox()
	// isBlockContainerBox()
	// isBox()
	// isParentBox()
}

func (BlockBox) isBlockBox()          {}
func (BlockBox) isBlockLevelBox()     {}
func (BlockBox) isBlockContainerBox() {}
func (BlockBox) isBox()               {}
func (BlockBox) isParentBox()         {}
func (b *BlockBox) Box() *BoxFields   { return &b.BoxFields }

// Copy is a shallow copy
func (b BlockBox) Copy() Box { return &b }

func (b BlockBox) String() string {
	return fmt.Sprintf("<BlockBox %s>", b.BoxFields.ElementTag)
}

func BlockBoxAnonymousFrom(parent Box, children []Box) *BlockBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewBlockBox(parent.Box().ElementTag, style, children)
	return &out
}

func (t typeBlockBox) IsInstance(box Box) bool {
	_, is := box.(instanceBlockBox)
	return is
}

func (b *BlockBox) Type() BoxType {
	return BlockBoxT
}

type typeBlockBox struct{}

func (t typeBlockBox) AnonymousFrom(parent Box, children []Box) Box {
	return BlockBoxAnonymousFrom(parent, children)
}

// A box that represents a line in an inline formatting context.
// Can only contain inline-level boxes.
// In early stages of building the box tree a single line box contains many
// consecutive inline boxes. Later, during layout phase, each line boxes will
// be split into multiple line boxes, one for each actual line.
type instanceLineBox interface {
	isLineBox()
	isBox()
	isParentBox()
}

func (LineBox) isLineBox()         {}
func (LineBox) isBox()             {}
func (LineBox) isParentBox()       {}
func (b *LineBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b LineBox) Copy() Box { return &b }

func (b LineBox) String() string {
	return fmt.Sprintf("<LineBox %s>", b.BoxFields.ElementTag)
}

func (t typeLineBox) IsInstance(box Box) bool {
	_, is := box.(instanceLineBox)
	return is
}

func (b *LineBox) Type() BoxType {
	return LineBoxT
}

type typeLineBox struct{}

func (t typeLineBox) AnonymousFrom(parent Box, children []Box) Box {
	return LineBoxAnonymousFrom(parent, children)
}

// A box that participates in an inline formatting context.
// An inline-level box that is not an inline box is said to be "atomic". Such
// boxes are inline blocks, replaced elements and inline tables.
// An element with a ``display`` value of ``inline``, ``inline-table``, or
// ``inline-block`` generates an inline-level box.
type instanceInlineLevelBox interface {
	isInlineLevelBox()
	isBox()
}

func IsInlineLevelBox(box Box) bool {
	_, is := box.(instanceInlineLevelBox)
	return is
}

// An inline box with inline children.
// A box that participates in an inline formatting context and whose content
// also participates in that inline formatting context.
// A non-replaced element with a ``display`` value of ``inline`` generates an
// inline box.
type instanceInlineBox interface {
	isInlineBox()
	isInlineLevelBox()
	isBox()
	isParentBox()
}

func (InlineBox) isInlineBox()       {}
func (InlineBox) isInlineLevelBox()  {}
func (InlineBox) isBox()             {}
func (InlineBox) isParentBox()       {}
func (b *InlineBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b InlineBox) Copy() Box { return &b }

func (b InlineBox) String() string {
	return fmt.Sprintf("<InlineBox %s>", b.BoxFields.ElementTag)
}

func InlineBoxAnonymousFrom(parent Box, children []Box) *InlineBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewInlineBox(parent.Box().ElementTag, style, children)
	return &out
}

func (t typeInlineBox) IsInstance(box Box) bool {
	_, is := box.(instanceInlineBox)
	return is
}

func (b *InlineBox) Type() BoxType {
	return InlineBoxT
}

type typeInlineBox struct{}

func (t typeInlineBox) AnonymousFrom(parent Box, children []Box) Box {
	return InlineBoxAnonymousFrom(parent, children)
}

// A box that contains only text and has no box children.
// Any text in the document ends up in a text box. What CSS calls "anonymous
// inline boxes" are also text boxes.
type instanceTextBox interface {
	isTextBox()
	isInlineLevelBox()
	isBox()
}

func (TextBox) isTextBox()         {}
func (TextBox) isInlineLevelBox()  {}
func (TextBox) isBox()             {}
func (b *TextBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b TextBox) Copy() Box { return &b }

func (b TextBox) String() string {
	return fmt.Sprintf("<TextBox %s>", b.BoxFields.ElementTag)
}

func TextBoxAnonymousFrom(parent Box, text string) *TextBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewTextBox(parent.Box().ElementTag, style, text)
	return &out
}

func IsTextBox(box Box) bool {
	_, is := box.(instanceTextBox)
	return is
}

// An atomic box in an inline formatting context.
// This inline-level box cannot be split for line breaks.
type instanceAtomicInlineLevelBox interface {
	isAtomicInlineLevelBox()
	isInlineLevelBox()
	isBox()
}

func IsAtomicInlineLevelBox(box Box) bool {
	_, is := box.(instanceAtomicInlineLevelBox)
	return is
}

// A box that is both inline-level and a block container.
// It behaves as inline on the outside and as a block on the inside.
// A non-replaced element with a 'display' value of 'inline-block' generates
// an inline-block box.
type instanceInlineBlockBox interface {
	isInlineBlockBox()
	isBlockContainerBox()
	isBox()
	isInlineLevelBox()
	isAtomicInlineLevelBox()
	isParentBox()
}

func (InlineBlockBox) isInlineBlockBox()       {}
func (InlineBlockBox) isBlockContainerBox()    {}
func (InlineBlockBox) isBox()                  {}
func (InlineBlockBox) isInlineLevelBox()       {}
func (InlineBlockBox) isAtomicInlineLevelBox() {}
func (InlineBlockBox) isParentBox()            {}
func (b *InlineBlockBox) Box() *BoxFields      { return &b.BoxFields }

// Copy is a shallow copy
func (b InlineBlockBox) Copy() Box { return &b }

func (b InlineBlockBox) String() string {
	return fmt.Sprintf("<InlineBlockBox %s>", b.BoxFields.ElementTag)
}

func InlineBlockBoxAnonymousFrom(parent Box, children []Box) *InlineBlockBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewInlineBlockBox(parent.Box().ElementTag, style, children)
	return &out
}

func (t typeInlineBlockBox) IsInstance(box Box) bool {
	_, is := box.(instanceInlineBlockBox)
	return is
}

func (b *InlineBlockBox) Type() BoxType {
	return InlineBlockBoxT
}

type typeInlineBlockBox struct{}

func (t typeInlineBlockBox) AnonymousFrom(parent Box, children []Box) Box {
	return InlineBlockBoxAnonymousFrom(parent, children)
}

// A box whose content is replaced.
// For example, ``<img>`` are replaced: their content is rendered externally
// and is opaque from CSSâ€™s point of view.
type instanceReplacedBox interface {
	isReplacedBox()
	isBox()
}

func (ReplacedBox) isReplacedBox()     {}
func (ReplacedBox) isBox()             {}
func (b *ReplacedBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b ReplacedBox) Copy() Box { return &b }

func (b ReplacedBox) String() string {
	return fmt.Sprintf("<ReplacedBox %s>", b.BoxFields.ElementTag)
}

func ReplacedBoxAnonymousFrom(parent Box, replacement images.Image) *ReplacedBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewReplacedBox(parent.Box().ElementTag, style, replacement)
	return &out
}

func IsReplacedBox(box Box) bool {
	_, is := box.(instanceReplacedBox)
	return is
}

// A box that is both replaced and block-level.
// A replaced element with a ``display`` value of ``block``, ``liste-item`` or
// ``table`` generates a block-level replaced box.
type instanceBlockReplacedBox interface {
	isBlockReplacedBox()
	isBlockLevelBox()
	isReplacedBox()
	isBox()
}

func (BlockReplacedBox) isBlockReplacedBox() {}
func (BlockReplacedBox) isBlockLevelBox()    {}
func (BlockReplacedBox) isReplacedBox()      {}
func (BlockReplacedBox) isBox()              {}
func (b *BlockReplacedBox) Box() *BoxFields  { return &b.BoxFields }

// Copy is a shallow copy
func (b BlockReplacedBox) Copy() Box { return &b }

func (b BlockReplacedBox) String() string {
	return fmt.Sprintf("<BlockReplacedBox %s>", b.BoxFields.ElementTag)
}

func BlockReplacedBoxAnonymousFrom(parent Box, replacement images.Image) *BlockReplacedBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewBlockReplacedBox(parent.Box().ElementTag, style, replacement)
	return &out
}

func IsBlockReplacedBox(box Box) bool {
	_, is := box.(instanceBlockReplacedBox)
	return is
}

// A box that is both replaced and inline-level.
// A replaced element with a ``display`` value of ``inline``,
// ``inline-table``, or ``inline-block`` generates an inline-level replaced
// box.
type instanceInlineReplacedBox interface {
	isInlineReplacedBox()
	isBox()
	isReplacedBox()
	isInlineLevelBox()
	isAtomicInlineLevelBox()
}

func (InlineReplacedBox) isInlineReplacedBox()    {}
func (InlineReplacedBox) isBox()                  {}
func (InlineReplacedBox) isReplacedBox()          {}
func (InlineReplacedBox) isInlineLevelBox()       {}
func (InlineReplacedBox) isAtomicInlineLevelBox() {}
func (b *InlineReplacedBox) Box() *BoxFields      { return &b.BoxFields }

// Copy is a shallow copy
func (b InlineReplacedBox) Copy() Box { return &b }

func (b InlineReplacedBox) String() string {
	return fmt.Sprintf("<InlineReplacedBox %s>", b.BoxFields.ElementTag)
}

func InlineReplacedBoxAnonymousFrom(parent Box, replacement images.Image) *InlineReplacedBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewInlineReplacedBox(parent.Box().ElementTag, style, replacement)
	return &out
}

func IsInlineReplacedBox(box Box) bool {
	_, is := box.(instanceInlineReplacedBox)
	return is
}

// Box for elements with ``display: table``
type instanceTableBox interface {
	isTableBox()
	isBlockLevelBox()
	isBox()
	isParentBox()
}

func (TableBox) isTableBox()        {}
func (TableBox) isBlockLevelBox()   {}
func (TableBox) isBox()             {}
func (TableBox) isParentBox()       {}
func (b *TableBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b TableBox) Copy() Box { return &b }

func (b TableBox) String() string {
	return fmt.Sprintf("<TableBox %s>", b.BoxFields.ElementTag)
}

func TableBoxAnonymousFrom(parent Box, children []Box) *TableBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewTableBox(parent.Box().ElementTag, style, children)
	return &out
}

func (t typeTableBox) IsInstance(box Box) bool {
	_, is := box.(instanceTableBox)
	return is
}

func (b *TableBox) Type() BoxType {
	return TableBoxT
}

type typeTableBox struct{}

func (t typeTableBox) AnonymousFrom(parent Box, children []Box) Box {
	return TableBoxAnonymousFrom(parent, children)
}

// Box for elements with ``display: inline-table``
type instanceInlineTableBox interface {
	isInlineTableBox()
	isBlockLevelBox()
	isTableBox()
	isBox()
	isParentBox()
}

func (InlineTableBox) isInlineTableBox()  {}
func (InlineTableBox) isBlockLevelBox()   {}
func (InlineTableBox) isTableBox()        {}
func (InlineTableBox) isBox()             {}
func (InlineTableBox) isParentBox()       {}
func (b *InlineTableBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b InlineTableBox) Copy() Box { return &b }

func (b InlineTableBox) String() string {
	return fmt.Sprintf("<InlineTableBox %s>", b.BoxFields.ElementTag)
}

func InlineTableBoxAnonymousFrom(parent Box, children []Box) *InlineTableBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewInlineTableBox(parent.Box().ElementTag, style, children)
	return &out
}

func (t typeInlineTableBox) IsInstance(box Box) bool {
	_, is := box.(instanceInlineTableBox)
	return is
}

func (b *InlineTableBox) Type() BoxType {
	return InlineTableBoxT
}

type typeInlineTableBox struct{}

func (t typeInlineTableBox) AnonymousFrom(parent Box, children []Box) Box {
	return InlineTableBoxAnonymousFrom(parent, children)
}

// Box for elements with ``display: table-row-group``
type instanceTableRowGroupBox interface {
	isTableRowGroupBox()
	isBox()
	isParentBox()
}

func (TableRowGroupBox) isTableRowGroupBox() {}
func (TableRowGroupBox) isBox()              {}
func (TableRowGroupBox) isParentBox()        {}
func (b *TableRowGroupBox) Box() *BoxFields  { return &b.BoxFields }

// Copy is a shallow copy
func (b TableRowGroupBox) Copy() Box { return &b }

func (b TableRowGroupBox) String() string {
	return fmt.Sprintf("<TableRowGroupBox %s>", b.BoxFields.ElementTag)
}

func TableRowGroupBoxAnonymousFrom(parent Box, children []Box) *TableRowGroupBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewTableRowGroupBox(parent.Box().ElementTag, style, children)
	return &out
}

func (t typeTableRowGroupBox) IsInstance(box Box) bool {
	_, is := box.(instanceTableRowGroupBox)
	return is
}

func (b *TableRowGroupBox) Type() BoxType {
	return TableRowGroupBoxT
}

type typeTableRowGroupBox struct{}

func (t typeTableRowGroupBox) AnonymousFrom(parent Box, children []Box) Box {
	return TableRowGroupBoxAnonymousFrom(parent, children)
}

// Box for elements with ``display: table-row``
type instanceTableRowBox interface {
	isTableRowBox()
	isBox()
	isParentBox()
}

func (TableRowBox) isTableRowBox()     {}
func (TableRowBox) isBox()             {}
func (TableRowBox) isParentBox()       {}
func (b *TableRowBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b TableRowBox) Copy() Box { return &b }

func (b TableRowBox) String() string {
	return fmt.Sprintf("<TableRowBox %s>", b.BoxFields.ElementTag)
}

func TableRowBoxAnonymousFrom(parent Box, children []Box) *TableRowBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewTableRowBox(parent.Box().ElementTag, style, children)
	return &out
}

func (t typeTableRowBox) IsInstance(box Box) bool {
	_, is := box.(instanceTableRowBox)
	return is
}

func (b *TableRowBox) Type() BoxType {
	return TableRowBoxT
}

type typeTableRowBox struct{}

func (t typeTableRowBox) AnonymousFrom(parent Box, children []Box) Box {
	return TableRowBoxAnonymousFrom(parent, children)
}

// Box for elements with ``display: table-column-group``
type instanceTableColumnGroupBox interface {
	isTableColumnGroupBox()
	isBox()
	isParentBox()
}

func (TableColumnGroupBox) isTableColumnGroupBox() {}
func (TableColumnGroupBox) isBox()                 {}
func (TableColumnGroupBox) isParentBox()           {}
func (b *TableColumnGroupBox) Box() *BoxFields     { return &b.BoxFields }

// Copy is a shallow copy
func (b TableColumnGroupBox) Copy() Box { return &b }

func (b TableColumnGroupBox) String() string {
	return fmt.Sprintf("<TableColumnGroupBox %s>", b.BoxFields.ElementTag)
}

func TableColumnGroupBoxAnonymousFrom(parent Box, children []Box) *TableColumnGroupBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewTableColumnGroupBox(parent.Box().ElementTag, style, children)
	return &out
}

func (t typeTableColumnGroupBox) IsInstance(box Box) bool {
	_, is := box.(instanceTableColumnGroupBox)
	return is
}

func (b *TableColumnGroupBox) Type() BoxType {
	return TableColumnGroupBoxT
}

type typeTableColumnGroupBox struct{}

func (t typeTableColumnGroupBox) AnonymousFrom(parent Box, children []Box) Box {
	return TableColumnGroupBoxAnonymousFrom(parent, children)
}

// Box for elements with ``display: table-column``
type instanceTableColumnBox interface {
	isTableColumnBox()
	isBox()
	isParentBox()
}

func (TableColumnBox) isTableColumnBox()  {}
func (TableColumnBox) isBox()             {}
func (TableColumnBox) isParentBox()       {}
func (b *TableColumnBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b TableColumnBox) Copy() Box { return &b }

func (b TableColumnBox) String() string {
	return fmt.Sprintf("<TableColumnBox %s>", b.BoxFields.ElementTag)
}

func TableColumnBoxAnonymousFrom(parent Box, children []Box) *TableColumnBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewTableColumnBox(parent.Box().ElementTag, style, children)
	return &out
}

func (t typeTableColumnBox) IsInstance(box Box) bool {
	_, is := box.(instanceTableColumnBox)
	return is
}

func (b *TableColumnBox) Type() BoxType {
	return TableColumnBoxT
}

type typeTableColumnBox struct{}

func (t typeTableColumnBox) AnonymousFrom(parent Box, children []Box) Box {
	return TableColumnBoxAnonymousFrom(parent, children)
}

// Box for elements with ``display: table-cell``
type instanceTableCellBox interface {
	isTableCellBox()
	isBlockContainerBox()
	isBox()
	isParentBox()
}

func (TableCellBox) isTableCellBox()      {}
func (TableCellBox) isBlockContainerBox() {}
func (TableCellBox) isBox()               {}
func (TableCellBox) isParentBox()         {}
func (b *TableCellBox) Box() *BoxFields   { return &b.BoxFields }

// Copy is a shallow copy
func (b TableCellBox) Copy() Box { return &b }

func (b TableCellBox) String() string {
	return fmt.Sprintf("<TableCellBox %s>", b.BoxFields.ElementTag)
}

func TableCellBoxAnonymousFrom(parent Box, children []Box) *TableCellBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewTableCellBox(parent.Box().ElementTag, style, children)
	return &out
}

func (t typeTableCellBox) IsInstance(box Box) bool {
	_, is := box.(instanceTableCellBox)
	return is
}

func (b *TableCellBox) Type() BoxType {
	return TableCellBoxT
}

type typeTableCellBox struct{}

func (t typeTableCellBox) AnonymousFrom(parent Box, children []Box) Box {
	return TableCellBoxAnonymousFrom(parent, children)
}

// Box for elements with ``display: table-caption``
type instanceTableCaptionBox interface {
	isTableCaptionBox()
	isBlockLevelBox()
	isBlockContainerBox()
	isBox()
	isBlockBox()
	isParentBox()
}

func (TableCaptionBox) isTableCaptionBox()   {}
func (TableCaptionBox) isBlockLevelBox()     {}
func (TableCaptionBox) isBlockContainerBox() {}
func (TableCaptionBox) isBox()               {}
func (TableCaptionBox) isBlockBox()          {}
func (TableCaptionBox) isParentBox()         {}
func (b *TableCaptionBox) Box() *BoxFields   { return &b.BoxFields }

// Copy is a shallow copy
func (b TableCaptionBox) Copy() Box { return &b }

func (b TableCaptionBox) String() string {
	return fmt.Sprintf("<TableCaptionBox %s>", b.BoxFields.ElementTag)
}

func TableCaptionBoxAnonymousFrom(parent Box, children []Box) *TableCaptionBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewTableCaptionBox(parent.Box().ElementTag, style, children)
	return &out
}

func (t typeTableCaptionBox) IsInstance(box Box) bool {
	_, is := box.(instanceTableCaptionBox)
	return is
}

func (b *TableCaptionBox) Type() BoxType {
	return TableCaptionBoxT
}

type typeTableCaptionBox struct{}

func (t typeTableCaptionBox) AnonymousFrom(parent Box, children []Box) Box {
	return TableCaptionBoxAnonymousFrom(parent, children)
}

// Box for a page.
// Initially the whole document will be in the box for the root element.
// During layout a new page box is created after every page break.
type instancePageBox interface {
	isPageBox()
	isBox()
	isParentBox()
}

func (PageBox) isPageBox()         {}
func (PageBox) isBox()             {}
func (PageBox) isParentBox()       {}
func (b *PageBox) Box() *BoxFields { return &b.BoxFields }

// Copy is a shallow copy
func (b PageBox) Copy() Box { return &b }

func IsPageBox(box Box) bool {
	_, is := box.(instancePageBox)
	return is
}

// Box in page margins, as defined in CSS3 Paged Media
type instanceMarginBox interface {
	isMarginBox()
	isBlockContainerBox()
	isBox()
	isParentBox()
}

func (MarginBox) isMarginBox()         {}
func (MarginBox) isBlockContainerBox() {}
func (MarginBox) isBox()               {}
func (MarginBox) isParentBox()         {}
func (b *MarginBox) Box() *BoxFields   { return &b.BoxFields }

// Copy is a shallow copy
func (b MarginBox) Copy() Box { return &b }

func IsMarginBox(box Box) bool {
	_, is := box.(instanceMarginBox)
	return is
}

// A box that contains only flex-items.
type instanceFlexContainerBox interface {
	isFlexContainerBox()
	isBox()
	isParentBox()
}

func IsFlexContainerBox(box Box) bool {
	_, is := box.(instanceFlexContainerBox)
	return is
}

// A box that is both block-level and a flex container.
// It behaves as block on the outside and as a flex container on the inside.
type instanceFlexBox interface {
	isFlexBox()
	isBlockLevelBox()
	isBox()
	isFlexContainerBox()
	isParentBox()
}

func (FlexBox) isFlexBox()          {}
func (FlexBox) isBlockLevelBox()    {}
func (FlexBox) isBox()              {}
func (FlexBox) isFlexContainerBox() {}
func (FlexBox) isParentBox()        {}
func (b *FlexBox) Box() *BoxFields  { return &b.BoxFields }

// Copy is a shallow copy
func (b FlexBox) Copy() Box { return &b }

func (b FlexBox) String() string {
	return fmt.Sprintf("<FlexBox %s>", b.BoxFields.ElementTag)
}

func FlexBoxAnonymousFrom(parent Box, children []Box) *FlexBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewFlexBox(parent.Box().ElementTag, style, children)
	return &out
}

func (t typeFlexBox) IsInstance(box Box) bool {
	_, is := box.(instanceFlexBox)
	return is
}

func (b *FlexBox) Type() BoxType {
	return FlexBoxT
}

type typeFlexBox struct{}

func (t typeFlexBox) AnonymousFrom(parent Box, children []Box) Box {
	return FlexBoxAnonymousFrom(parent, children)
}

// A box that is both inline-level and a flex container.
// It behaves as inline on the outside and as a flex container on the inside.
type instanceInlineFlexBox interface {
	isInlineFlexBox()
	isBox()
	isFlexContainerBox()
	isInlineLevelBox()
	isParentBox()
}

func (InlineFlexBox) isInlineFlexBox()    {}
func (InlineFlexBox) isBox()              {}
func (InlineFlexBox) isFlexContainerBox() {}
func (InlineFlexBox) isInlineLevelBox()   {}
func (InlineFlexBox) isParentBox()        {}
func (b *InlineFlexBox) Box() *BoxFields  { return &b.BoxFields }

// Copy is a shallow copy
func (b InlineFlexBox) Copy() Box { return &b }

func (b InlineFlexBox) String() string {
	return fmt.Sprintf("<InlineFlexBox %s>", b.BoxFields.ElementTag)
}

func InlineFlexBoxAnonymousFrom(parent Box, children []Box) *InlineFlexBox {
	style := tree.ComputedFromCascaded(nil, nil, parent.Box().Style, nil, "", "", nil)
	out := NewInlineFlexBox(parent.Box().ElementTag, style, children)
	return &out
}

func (t typeInlineFlexBox) IsInstance(box Box) bool {
	_, is := box.(instanceInlineFlexBox)
	return is
}

func (b *InlineFlexBox) Type() BoxType {
	return InlineFlexBoxT
}

type typeInlineFlexBox struct{}

func (t typeInlineFlexBox) AnonymousFrom(parent Box, children []Box) Box {
	return InlineFlexBoxAnonymousFrom(parent, children)
}

var (
	BlockBoxT            BoxType = typeBlockBox{}
	LineBoxT             BoxType = typeLineBox{}
	InlineBoxT           BoxType = typeInlineBox{}
	InlineBlockBoxT      BoxType = typeInlineBlockBox{}
	TableBoxT            BoxType = typeTableBox{}
	InlineTableBoxT      BoxType = typeInlineTableBox{}
	TableRowGroupBoxT    BoxType = typeTableRowGroupBox{}
	TableRowBoxT         BoxType = typeTableRowBox{}
	TableColumnGroupBoxT BoxType = typeTableColumnGroupBox{}
	TableColumnBoxT      BoxType = typeTableColumnBox{}
	TableCellBoxT        BoxType = typeTableCellBox{}
	TableCaptionBoxT     BoxType = typeTableCaptionBox{}
	FlexBoxT             BoxType = typeFlexBox{}
	InlineFlexBoxT       BoxType = typeInlineFlexBox{}
)
