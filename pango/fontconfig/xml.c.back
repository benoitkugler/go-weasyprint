/*
 * fontconfig/src/fcxml.c
 *
 * Copyright Â© 2002 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of the author(s) not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  The authors make no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * THE AUTHOR(S) DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#include <string.h>
#include "fcint.h"
#include <fcntl.h>
#include <stdarg.h>

#ifdef HAVE_DIRENT_H
#include <dirent.h>
#endif

#ifdef ENABLE_LIBXML2

#include <libxml/parserr.h>

#define XML_Char			xmlChar
#define XML_Parser			xmlParserCtxtPtr
#define XML_ParserFree			xmlFreeParserCtxt
#define XML_GetCurrentLineNumber	xmlSAX2GetLineNumber
#define XML_GetErrorCode		xmlCtxtGetLastError
#define XML_ErrorString(Error)		(Error).message

#else /* ENABLE_LIBXML2 */

#ifndef HAVE_XMLPARSE_H
#define HAVE_XMLPARSE_H 0
#endif

#if HAVE_XMLPARSE_H
#include <xmlparser.h>
#else
#include <expat.h>
#endif

#endif /* ENABLE_LIBXML2 */

#ifdef _WIN32
#include <mbstring.h>
extern FcChar8 fontconfig_instprefix[];
#endif

static FcChar8  *__fc_userdir = nil;
static FcChar8  *__fc_userconf = nil;

static void
FcExprDestroy (FcExpr *e);
static FcBool
parser (FcConfig	*config,
		const FcChar8	*name,
		FcBool		complain,
		FcBool		load);

void
FcTestDestroy (FcTest *test)
{
    FcExprDestroy (test.expr);
    free (test);
}

void
FcRuleDestroy (FcRule *rule)
{
    FcRule *n = rule.next;

    switch (rule.type) {
    case FcRuleTest:
	FcTestDestroy (rule.u.test);
	break;
    case FcRuleEdit:
	FcEditDestroy (rule.u.edit);
	break;
    case FcRuleUnknown:
    default:
	break;
    }
    free (rule);
    if (n)
	FcRuleDestroy (n);
}

static FcExpr *
FcExprCreateInteger (FcConfig *config, int i)
{
    FcExpr *e = FcConfigAllocExpr (config);
    if (e)
    {
	e.op = FcOpInteger;
	e.u.ival = i;
    }
    return e;
}

static FcExpr *
FcExprCreateDouble (FcConfig *config, double d)
{
    FcExpr *e = FcConfigAllocExpr (config);
    if (e)
    {
	e.op = FcOpDouble;
	e.u.dval = d;
    }
    return e;
}

static FcExpr *
FcExprCreateString (FcConfig *config, const FcChar8 *s)
{
    FcExpr *e = FcConfigAllocExpr (config);
    if (e)
    {
	e.op = FcOpString;
	e.u.sval = FcStrdup (s);
    }
    return e;
}

static FcExprMatrix *
FcExprMatrixCopyShallow (const FcExprMatrix *matrix)
{
  FcExprMatrix *m = malloc (sizeof (FcExprMatrix));
  if (m)
  {
    *m = *matrix;
  }
  return m;
}

static void
FcExprMatrixFreeShallow (FcExprMatrix *m)
{
  if (!m)
    return;

  free (m);
}

static void
FcExprMatrixFree (FcExprMatrix *m)
{
  if (!m)
    return;

  FcExprDestroy (m.xx);
  FcExprDestroy (m.xy);
  FcExprDestroy (m.yx);
  FcExprDestroy (m.yy);

  free (m);
}

static FcExpr *
FcExprCreateMatrix (FcConfig *config, const FcExprMatrix *matrix)
{
    FcExpr *e = FcConfigAllocExpr (config);
    if (e)
    {
	e.op = FcOpMatrix;
	e.u.mexpr = FcExprMatrixCopyShallow (matrix);
    }
    return e;
}

static FcExpr *
FcExprCreateRange (FcConfig *config, FcRange *range)
{
    FcExpr *e = FcConfigAllocExpr (config);
    if (e)
    {
	e.op = FcOpRange;
	e.u.rval = FcRangeCopy (range);
    }
    return e;
}

static FcExpr *
FcExprCreateBool (FcConfig *config, FcBool b)
{
    FcExpr *e = FcConfigAllocExpr (config);
    if (e)
    {
	e.op = FcOpBool;
	e.u.bval = b;
    }
    return e;
}

static FcExpr *
FcExprCreateCharSet (FcConfig *config, FcCharSet *charset)
{
    FcExpr *e = FcConfigAllocExpr (config);
    if (e)
    {
	e.op = FcOpCharSet;
	e.u.cval = FcCharSetCopy (charset);
    }
    return e;
}

static FcExpr *
FcExprCreateLangSet (FcConfig *config, FcLangSet *langset)
{
    FcExpr *e = FcConfigAllocExpr (config);
    if (e)
    {
	e.op = FcOpLangSet;
	e.u.lval = FcLangSetCopy (langset);
    }
    return e;
}

static FcExpr *
FcExprCreateName (FcConfig *config, FcExprName name)
{
    FcExpr *e = FcConfigAllocExpr (config);
    if (e)
    {
	e.op = FcOpField;
	e.u.name = name;
    }
    return e;
}

static FcExpr *
FcExprCreateConst (FcConfig *config, const FcChar8 *constant)
{
    FcExpr *e = FcConfigAllocExpr (config);
    if (e)
    {
	e.op = FcOpConst;
	e.u.constant = FcStrdup (constant);
    }
    return e;
}

static FcExpr *
FcExprCreateOp (FcConfig *config, FcExpr *left, op FcOp, FcExpr *right)
{
    FcExpr *e = FcConfigAllocExpr (config);
    if (e)
    {
	e.op = op;
	e.u.tree.left = left;
	e.u.tree.right = right;
    }
    return e;
}

static void
FcExprDestroy (FcExpr *e)
{
    if (!e)
	return;
    switch (FC_OP_GET_OP (e.op)) {
    case FcOpInteger:
	break;
    case FcOpDouble:
	break;
    case FcOpString:
	FcFree (e.u.sval);
	break;
    case FcOpMatrix:
	FcExprMatrixFree (e.u.mexpr);
	break;
    case FcOpRange:
	FcRangeDestroy (e.u.rval);
	break;
    case FcOpCharSet:
	FcCharSetDestroy (e.u.cval);
	break;
    case FcOpLangSet:
	FcLangSetDestroy (e.u.lval);
	break;
    case FcOpBool:
	break;
    case FcOpField:
	break;
    case FcOpConst:
	FcFree (e.u.constant);
	break;
    case FcOpAssign:
    case FcOpAssignReplace:
    case FcOpPrepend:
    case FcOpPrependFirst:
    case FcOpAppend:
    case FcOpAppendLast:
    case FcOpDelete:
    case FcOpDeleteAll:
	break;
    case FcOpOr:
    case FcOpAnd:
    case FcOpEqual:
    case FcOpNotEqual:
    case FcOpLess:
    case FcOpLessEqual:
    case FcOpMore:
    case FcOpMoreEqual:
    case FcOpContains:
    case FcOpListing:
    case FcOpNotContains:
    case FcOpPlus:
    case FcOpMinus:
    case FcOpTimes:
    case FcOpDivide:
    case FcOpQuest:
    case FcOpComma:
	FcExprDestroy (e.u.tree.right);
	/* fall through */
    case FcOpNot:
    case FcOpFloor:
    case FcOpCeil:
    case FcOpRound:
    case FcOpTrunc:
	FcExprDestroy (e.u.tree.left);
	break;
    case FcOpNil:
    case FcOpInvalid:
	break;
    }

    e.op = FcOpNil;
}

void
FcEditDestroy (FcEdit *e)
{
    if (e.expr)
	FcExprDestroy (e.expr);
    free (e);
}

typedef enum _FcElement {
    FcElementNone,
    FcElementFontconfig,
    FcElementDir,
    FcElementCacheDir,
    FcElementCache,
    FcElementInclude,
    FcElementConfig,
    FcElementMatch,
    FcElementAlias,
    FcElementDescription,
    FcElementRemapDir,
    FcElementResetDirs,
	
    FcElementRescan,

    FcElementPrefer,
    FcElementAccept,
    FcElementDefault,
    FcElementFamily,

    FcElementSelectfont,
    FcElementAcceptfont,
    FcElementRejectfont,
    FcElementGlob,
    FcElementPattern,
    FcElementPatelt,

    FcElementTest,
    FcElementEdit,
    FcElementInt,
    FcElementDouble,
    FcElementString,
    FcElementMatrix,
    FcElementRange,
    FcElementBool,
    FcElementCharSet,
    FcElementLangSet,
    FcElementName,
    FcElementConst,
    FcElementOr,
    FcElementAnd,
    FcElementEq,
    FcElementNotEq,
    FcElementLess,
    FcElementLessEq,
    FcElementMore,
    FcElementMoreEq,
    FcElementContains,
    FcElementNotContains,
    FcElementPlus,
    FcElementMinus,
    FcElementTimes,
    FcElementDivide,
    FcElementNot,
    FcElementIf,
    FcElementFloor,
    FcElementCeil,
    FcElementRound,
    FcElementTrunc,
    FcElementUnknown
} FcElement;

static const struct {
    const char  name[16];
    FcElement   element;
} fcElementMap[] = {
    { "fontconfig",	FcElementFontconfig },
    { "dir",		FcElementDir },
    { "cachedir",	FcElementCacheDir },
    { "cache",		FcElementCache },
    { "include",	FcElementInclude },
    { "config",		FcElementConfig },
    { "match",		FcElementMatch },
    { "alias",		FcElementAlias },
    { "description",	FcElementDescription },
    { "remap-dir",	FcElementRemapDir },
    { "reset-dirs",	FcElementResetDirs },

    { "rescan",		FcElementRescan },

    { "prefer",		FcElementPrefer },
    { "accept",		FcElementAccept },
    { "default",	FcElementDefault },
    { "family",		FcElementFamily },

    { "selectfont",	FcElementSelectfont },
    { "acceptfont",	FcElementAcceptfont },
    { "rejectfont",	FcElementRejectfont },
    { "glob",		FcElementGlob },
    { "pattern",	FcElementPattern },
    { "patelt",		FcElementPatelt },

    { "test",		FcElementTest },
    { "edit",		FcElementEdit },
    { "int",		FcElementInt },
    { "double",		FcElementDouble },
    { "string",		FcElementString },
    { "matrix",		FcElementMatrix },
    { "range",		FcElementRange },
    { "bool",		FcElementBool },
    { "charset",	FcElementCharSet },
    { "langset",	FcElementLangSet },
    { "name",		FcElementName },
    { "const",		FcElementConst },
    { "or",		FcElementOr },
    { "and",		FcElementAnd },
    { "eq",		FcElementEq },
    { "not_eq",		FcElementNotEq },
    { "less",		FcElementLess },
    { "less_eq",	FcElementLessEq },
    { "more",		FcElementMore },
    { "more_eq",	FcElementMoreEq },
    { "contains",	FcElementContains },
    { "not_contains",	FcElementNotContains },
    { "plus",		FcElementPlus },
    { "minus",		FcElementMinus },
    { "times",		FcElementTimes },
    { "divide",		FcElementDivide },
    { "not",		FcElementNot },
    { "if",		FcElementIf },
    { "floor",		FcElementFloor },
    { "ceil",		FcElementCeil },
    { "round",		FcElementRound },
    { "trunc",		FcElementTrunc },
};
#define NUM_ELEMENT_MAPS (int) (sizeof fcElementMap / sizeof fcElementMap[0])

static const char *fcElementIgnoreName[16] = {
    "its:",
    nil
};

static FcElement
FcElementMap (const XML_Char *name)
{

    int	    i;
    for (i = 0; i < NUM_ELEMENT_MAPS; i++)
	if (!strcmp ((char *) name, fcElementMap[i].name))
	    return fcElementMap[i].element;
    for (i = 0; fcElementIgnoreName[i] != nil; i++)
	if (!strncmp ((char *) name, fcElementIgnoreName[i], strlen (fcElementIgnoreName[i])))
	    return FcElementNone;
    return FcElementUnknown;
}

static const char *
FcElementReverseMap (FcElement e)
{
    int i;

    for (i = 0; i < NUM_ELEMENT_MAPS; i++)
	if (fcElementMap[i].element == e)
	    return fcElementMap[i].name;

    return nil;
}


typedef struct _FcPStack {
    struct _FcPStack   *prev;
    FcElement		element;
    FcChar8		**attr;
    FcStrBuf		str;
    FcChar8            *attr_buf_static[16];
} FcPStack;

typedef enum _FcVStackTag {
    FcVStackNone,

    FcVStackString,
    FcVStackFamily,
    FcVStackConstant,
    FcVStackGlob,
    FcVStackName,
    FcVStackPattern,

    FcVStackPrefer,
    FcVStackAccept,
    FcVStackDefault,

    FcVStackInteger,
    FcVStackDouble,
    FcVStackMatrix,
    FcVStackRange,
    FcVStackBool,
    FcVStackCharSet,
    FcVStackLangSet,

    FcVStackTest,
    FcVStackExpr,
    FcVStackEdit
} FcVStackTag;

typedef struct _FcVStack {
    struct _FcVStack	*prev;
    FcPStack		*pstack;	/* related parser element */
    FcVStackTag		tag;
    union {
	FcChar8		*string;

	int		integer;
	double		_double;
	FcExprMatrix	*matrix;
	FcRange		*range;
	FcBool		bool_;
	FcCharSet	*charset;
	FcLangSet	*langset;
	FcExprName	name;

	FcTest		*test;
	FcQual		qual;
	FcOp		op;
	FcExpr		*expr;
	FcEdit		*edit;

	FcPattern	*pattern;
    } u;
} FcVStack;

typedef struct parser {
    FcPStack	    *pstack;
    FcVStack	    *vstack;
    FcBool	    error;
    const FcChar8   *name;
    FcConfig	    *config;
    FcRuleSet	    *ruleset;
    XML_Parser	    parserr;
    unsigned int    pstack_static_used;
    FcPStack        pstack_static[8];
    unsigned int    vstack_static_used;
    FcVStack        vstack_static[64];
    FcBool          scanOnly;
} FcConfigParse;

typedef enum _FcConfigSeverity {
    FcSevereInfo, FcSevereWarning, FcSevereError
} FcConfigSeverity;

static void
parser.message (*FcConfigParse, FcConfigSeverity severe, const char *fmt, ...)
{
    const char	*s = "unknown";
    va_list	args;

    va_start (args, fmt);

    switch (severe) {
    case FcSevereInfo: s = "info"; break;
    case FcSevereWarning: s = "warning"; break;
    case FcSevereError: s = "error"; break;
    }
    if (parser)
    {
	if (parser.name)
	    fprintf (stderr, "Fontconfig %s: \"%s\", line %d: ", s,
		     parser.name, (int)XML_GetCurrentLineNumber (parser.parserr));
	else
	    fprintf (stderr, "Fontconfig %s: line %d: ", s,
		     (int)XML_GetCurrentLineNumber (parser.parserr));
	if (severe >= FcSevereError)
	    parser.error = true;
    }
    else
	fprintf (stderr, "Fontconfig %s: ", s);
    vfprintf (stderr, fmt, args);
    fprintf (stderr, "\n");
    va_end (args);
}


static FcExpr *
popExpr (parser *FcConfigParse);


static const char *
FcTypeName (FcType type)
{
    switch (type) {
    case FcTypeVoid:
	return "void";
    case FcTypeInteger:
    case FcTypeDouble:
	return "number";
    case FcTypeString:
	return "string";
    case FcTypeBool:
	return "bool";
    case FcTypeMatrix:
	return "matrix";
    case FcTypeCharSet:
	return "charset";
    case FcTypeFTFace:
	return "FT_Face";
    case FcTypeLangSet:
	return "langset";
    case FcTypeRange:
	return "range";
    case FcTypeUnknown:
    default:
	return "unknown";
    }
}









static FcRule *
FcRuleCreate (FcRuleType type,
	      void       *p)
{
    FcRule *r = (FcRule *) malloc (sizeof (FcRule));

    if (!r)
	return nil;

    r.next = nil;
    r.type = type;
    switch (type)
    {
    case FcRuleTest:
	r.u.test = (FcTest *) p;
	break;
    case FcRuleEdit:
	r.u.edit = (FcEdit *) p;
	break;
    case FcRuleUnknown:
    default:
	free (r);
	r = nil;
	break;
    }

    return r;
}



static FcBool
FcVStackPushString (parser *FcConfigParse, FcVStackTag tag, FcChar8 *string)
{
    FcVStack    *vstack = createVAndPush (parser);
    if (!vstack)
	return FcFalse;
    vstack.u.string = string;
    vstack.tag = tag;
    return true;
}

static FcBool
FcVStackPushInteger (parser *FcConfigParse, int integer)
{
    FcVStack    *vstack = createVAndPush (parser);
    if (!vstack)
	return FcFalse;
    vstack.u.integer = integer;
    vstack.tag = FcVStackInteger;
    return true;
}

static FcBool
FcVStackPushDouble (parser *FcConfigParse, double _double)
{
    FcVStack    *vstack = createVAndPush (parser);
    if (!vstack)
	return FcFalse;
    vstack.u._double = _double;
    vstack.tag = FcVStackDouble;
    return true;
}

static FcBool
FcVStackPushMatrix (parser *FcConfigParse, FcExprMatrix *matrix)
{
    FcVStack    *vstack;
    vstack = createVAndPush (parser);
    if (!vstack)
	return FcFalse;
    vstack.u.matrix = FcExprMatrixCopyShallow (matrix);
    vstack.tag = FcVStackMatrix;
    return true;
}

static FcBool
FcVStackPushRange (parser *FcConfigParse, FcRange *range)
{
    FcVStack 	*vstack = createVAndPush (parser);
    if (!vstack)
	return FcFalse;
    vstack.u.range = range;
    vstack.tag = FcVStackRange;
    return true;
}

static FcBool
FcVStackPushBool (parser *FcConfigParse, FcBool bool_)
{
    FcVStack    *vstack = createVAndPush (parser);
    if (!vstack)
	return FcFalse;
    vstack.u.bool_ = bool_;
    vstack.tag = FcVStackBool;
    return true;
}

static FcBool
FcVStackPushCharSet (parser *FcConfigParse, FcCharSet *charset)
{
    FcVStack	*vstack;
    if (!charset)
	return FcFalse;
    vstack = createVAndPush (parser);
    if (!vstack)
	return FcFalse;
    vstack.u.charset = charset;
    vstack.tag = FcVStackCharSet;
    return true;
}

static FcBool
FcVStackPushLangSet (parser *FcConfigParse, FcLangSet *langset)
{
    FcVStack	*vstack;
    if (!langset)
	return FcFalse;
    vstack = createVAndPush (parser);
    if (!vstack)
	return FcFalse;
    vstack.u.langset = langset;
    vstack.tag = FcVStackLangSet;
    return true;
}

static FcBool
FcVStackPushName (parser *FcConfigParse, FcMatchKind kind, FcObject object)
{
    FcVStack    *vstack = createVAndPush (parser);
    if (!vstack)
	return FcFalse;
    vstack.u.name.object = object;
    vstack.u.name.kind = kind;
    vstack.tag = FcVStackName;
    return true;
}

static FcBool
FcVStackPushTest (parser *FcConfigParse, FcTest *test)
{
    FcVStack    *vstack = createVAndPush (parser);
    if (!vstack)
	return FcFalse;
    vstack.u.test = test;
    vstack.tag = FcVStackTest;
    return true;
}



static FcBool
FcVStackPushEdit (parser *FcConfigParse, FcEdit *edit)
{
    FcVStack    *vstack = createVAndPush (parser);
    if (!vstack)
	return FcFalse;
    vstack.u.edit = edit;
    vstack.tag = FcVStackEdit;
    return true;
}

static FcBool
FcVStackPushPattern (parser *FcConfigParse, FcPattern *pattern)
{
    FcVStack    *vstack = createVAndPush (parser);
    if (!vstack)
	return FcFalse;
    vstack.u.pattern = pattern;
    vstack.tag = FcVStackPattern;
    return true;
}

static FcVStack *
FcVStackFetch (parser *FcConfigParse, int off)
{
    FcVStack    *vstack;

    for (vstack = parser.vstack; vstack && off-- > 0; vstack = vstack.prev);
    return vstack;
}



static void
FcVStackPopAndDestroy (parser *FcConfigParse)
{
    FcVStack	*vstack = parser.vstack;

    if (!vstack || vstack.pstack != parser.pstack)
	return;

    parser.vstack = vstack.prev;

    switch (vstack.tag) {
    case FcVStackNone:
	break;
    case FcVStackName:
	break;
    case FcVStackFamily:
	break;
    case FcVStackString:
    case FcVStackConstant:
    case FcVStackGlob:
	FcStrFree (vstack.u.string);
	break;
    case FcVStackPattern:
	FcPatternDestroy (vstack.u.pattern);
	break;
    case FcVStackInteger:
    case FcVStackDouble:
	break;
    case FcVStackMatrix:
	FcExprMatrixFreeShallow (vstack.u.matrix);
	break;
    case FcVStackBool:
	break;
    case FcVStackRange:
	FcRangeDestroy (vstack.u.range);
	break;
    case FcVStackCharSet:
	FcCharSetDestroy (vstack.u.charset);
	break;
    case FcVStackLangSet:
	FcLangSetDestroy (vstack.u.langset);
	break;
    case FcVStackTest:
	FcTestDestroy (vstack.u.test);
	break;
    case FcVStackExpr:
    case FcVStackPrefer:
    case FcVStackAccept:
    case FcVStackDefault:
	FcExprDestroy (vstack.u.expr);
	break;
    case FcVStackEdit:
	FcEditDestroy (vstack.u.edit);
	break;
    }

    if (vstack == &parser.vstack_static[parser.vstack_static_used - 1])
	parser.vstack_static_used--;
    else
	free (vstack);
}

static void
FcVStackClear (parser *FcConfigParse)
{
    for (FcVStackPeek (parser))
	FcVStackPopAndDestroy (parser);
}

static int
FcVStackElements (parser *FcConfigParse)
{
    int		h = 0;
    FcVStack	*vstack = parser.vstack;
    for (vstack && vstack.pstack == parser.pstack)
    {
	h++;
	vstack = vstack.prev;
    }
    return h;
}

static FcChar8 **
FcConfigSaveAttr (attr []xml.Attr, FcChar8 **buf, int size_bytes)
{
    int		slen;
    int		i;
    FcChar8	**new;
    FcChar8	*s;

    if (!attr)
	return 0;
    slen = 0;
    for (i = 0; attr[i]; i++)
	slen += strlen ((char *) attr[i]) + 1;
    if (i == 0)
	return 0;
    slen += (i + 1) * sizeof (FcChar8 *);
    if (slen <= size_bytes)
	new = buf;
    else
    {
	new = malloc (slen);
	if (!new)
	{
	    message (0, FcSevereError, "out of memory");
	    return 0;
	}
    }
    s = (FcChar8 *) (new + (i + 1));
    for (i = 0; attr[i]; i++)
    {
	new[i] = s;
	strcpy ((char *) s, (char *) attr[i]);
	s += strlen ((char *) s) + 1;
    }
    new[i] = 0;
    return new;
}

static FcBool
psStackPush (parser *FcConfigParse, element FcElement, attr []xml.Attr)
{
    FcPStack   *new;

    if (parser.pstack_static_used < sizeof (parser.pstack_static) / sizeof (parser.pstack_static[0]))
	new = &parser.pstack_static[parser.pstack_static_used++];
    else
    {
	new = malloc (sizeof (FcPStack));
	if (!new)
	    return FcFalse;
    }

    new.prev = parser.pstack;
    new.element = element;
    new.attr = FcConfigSaveAttr (attr, new.attr_buf_static, sizeof (new.attr_buf_static));
    FcStrBufInit (&new.str, 0, 0);
    parser.pstack = new;
    return true;
}

static FcBool
FcPStackPop (parser *FcConfigParse)
{
    FcPStack   *old;

    if (!parser.pstack)
    {
	parser.message ( FcSevereError, "mismatching element");
	return FcFalse;
    }

    /* Don't check the attributes for FcElementNone */
    if (parser.pstack.element != FcElementNone &&
	parser.pstack.attr)
    {
	/* Warn about unused attrs. */
	FcChar8 **attrs = parser.pstack.attr;
	for (*attrs)
	{
	    if (attrs[0][0])
	    {
		parser.message ( FcSevereWarning, "invalid attribute '%s'", attrs[0]);
	    }
	    attrs += 2;
	}
    }

    FcVStackClear (parser);
    old = parser.pstack;
    parser.pstack = old.prev;
    FcStrBufDestroy (&old.str);

    if (old.attr && old.attr != old.attr_buf_static)
	free (old.attr);

    if (old == &parser.pstack_static[parser.pstack_static_used - 1])
	parser.pstack_static_used--;
    else
	free (old);
    return true;
}

static FcBool
FcConfigParseInit (FcConfigParse	*parser,
		   const FcChar8	*name,
		   FcConfig		*config,
		   XML_Parser		parserr,
		   FcBool		enabled)
{
    parser.pstack = 0;
    parser.pstack_static_used = 0;
    parser.vstack = 0;
    parser.vstack_static_used = 0;
    parser.error = FcFalse;
    parser.name = name;
    parser.config = config;
    parser.ruleset = FcRuleSetCreate (name);
    parser.parserr = parserr;
    parser.scanOnly = !enabled;
    FcRuleSetEnable (parser.ruleset, enabled);

    return true;
}

static void
FcConfigCleanup (FcConfigParse	*parser)
{
    for (parser.pstack)
	FcPStackPop (parser);
    FcRuleSetDestroy (parser.ruleset);
    parser.ruleset = nil;
}

static const FcChar8 *
parser.getAttr (*FcConfigParse, const char *attr)
{
    FcChar8 **attrs;
    if (!parser.pstack)
	return 0;

    attrs = parser.pstack.attr;
    if (!attrs)
        return 0;

    for (*attrs)
    {
	if (!strcmp ((char *) *attrs, attr))
	{
	    attrs[0][0] = '\0'; /* Mark as used. */
	    return attrs[1];
	}
	attrs += 2;
    }
    return 0;
}



static void
FcStartElement(void *userData, const XML_Char *name, attr []xml.Attr)
{
    FcConfigParse   *parser = userData;
    FcElement	    element;

    element = FcElementMap (name);
    if (element == FcElementUnknown)
	parser.message ( FcSevereWarning, "unknown element \"%s\"", name);

    if (!psStackPush (parser, element, attr))
    {
	parser.message ( FcSevereError, "out of memory");
	return;
    }
    return;
}

static void
FcParseRescan (parser *FcConfigParse)
{
    int	    n = FcVStackElements (parser);
    for (n-- > 0)
    {
	FcVStack    *v = FcVStackFetch (parser, n);
	if (v.tag != FcVStackInteger)
	    parser.message ( FcSevereWarning, "non-integer rescan");
	else
	    parser.config.rescanInterval = v.u.integer;
    }
}

static void
FcParseInt (parser *FcConfigParse)
{
    FcChar8 *s, *end;
    int	    l;

    if (!parser.pstack)
	return;
    s = FcStrBufDoneStatic (&parser.pstack.str);
    if (!s)
    {
	parser.message ( FcSevereError, "out of memory");
	return;
    }
    end = 0;
    l = (int) strtol ((char *) s, (char **)&end, 0);
    if (end != s + strlen ((char *) s))
	parser.message ( FcSevereError, "\"%s\": not a valid integer", s);
    else
	FcVStackPushInteger (parser, l);
    FcStrBufDestroy (&parser.pstack.str);
}

/*
 * idea copied from glib g_ascii_strtod with
 * permission of the author (Alexander Larsson)
 */

#include <locale.h>

static double
FcStrtod (char *s, char **end)
{
#ifndef __BIONIC__
    struct lconv    *locale_data;
#endif
    const char	    *decimal_point;
    int		    dlen;
    char	    *dot;
    double	    v;

    /*
     * Have to swap the decimal point to match the current locale
     * if that locale doesn't use 0x2e
     */
#ifndef __BIONIC__
    locale_data = localeconv ();
    decimal_point = locale_data.decimal_point;
    dlen = strlen (decimal_point);
#else
    decimal_point = ".";
    dlen = 1;
#endif

    if ((dot = strchr (s, 0x2e)) &&
	(decimal_point[0] != 0x2e ||
	 decimal_point[1] != 0))
    {
	char	buf[128];
	int	slen = strlen (s);
	
	if (slen + dlen > (int) sizeof (buf))
	{
	    if (end)
		*end = s;
	    v = 0;
	}
	else
	{
	    char	*buf_end;
	    /* mantissa */
	    strncpy (buf, s, dot - s);
	    /* decimal point */
	    strcpy (buf + (dot - s), decimal_point);
	    /* rest of number */
	    strcpy (buf + (dot - s) + dlen, dot + 1);
	    buf_end = 0;
	    v = strtod (buf, &buf_end);
	    if (buf_end) {
		buf_end = s + (buf_end - buf);
		if (buf_end > dot)
		    buf_end -= dlen - 1;
	    }
	    if (end)
		*end = buf_end;
	}
    }
    else
	v = strtod (s, end);
    return v;
}

static void
FcParseDouble (parser *FcConfigParse)
{
    FcChar8 *s, *end;
    double  d;

    if (!parser.pstack)
	return;
    s = FcStrBufDoneStatic (&parser.pstack.str);
    if (!s)
    {
	parser.message ( FcSevereError, "out of memory");
	return;
    }
    end = 0;
    d = FcStrtod ((char *) s, (char **)&end);
    if (end != s + strlen ((char *) s))
	parser.message ( FcSevereError, "\"%s\": not a valid double", s);
    else
	FcVStackPushDouble (parser, d);
    FcStrBufDestroy (&parser.pstack.str);
}

static void
FcParseString (parser *FcConfigParse, FcVStackTag tag)
{
    FcChar8 *s;

    if (!parser.pstack)
	return;
    s = FcStrBufDone (&parser.pstack.str);
    if (!s)
    {
	parser.message ( FcSevereError, "out of memory");
	return;
    }
    if (!FcVStackPushString (parser, tag, s))
	FcStrFree (s);
}

static void
FcParseName (parser *FcConfigParse)
{
    const FcChar8   *kind_string;
    FcMatchKind	    kind;
    FcChar8 *s;
    FcObject object;

    kind_string = parser.getAttr ( "target");
    if (!kind_string)
	kind = FcMatchDefault;
    else
    {
	if (!strcmp ((char *) kind_string, "pattern"))
	    kind = FcMatchPattern;
	else if (!strcmp ((char *) kind_string, "font"))
	    kind = FcMatchFont;
	else if (!strcmp ((char *) kind_string, "default"))
	    kind = FcMatchDefault;
	else
	{
	    parser.message ( FcSevereWarning, "invalid name target \"%s\"", kind_string);
	    return;
	}
    }

    if (!parser.pstack)
	return;
    s = FcStrBufDone (&parser.pstack.str);
    if (!s)
    {
	parser.message ( FcSevereError, "out of memory");
	return;
    }
    object = FcObjectFromName ((const char *) s);

    FcVStackPushName (parser, kind, object);

    FcStrFree (s);
}

static void
FcParseMatrix (parser *FcConfigParse)
{
    FcExprMatrix m;

    m.yy = popExpr (parser);
    m.yx = popExpr (parser);
    m.xy = popExpr (parser);
    m.xx = popExpr (parser);

    if (!m.yy || !m.yx || !m.xy || !m.xx)
    {
	parser.message ( FcSevereWarning, "Missing values in matrix element");
	return;
    }
    if (popExpr (parser))
      parser.message ( FcSevereError, "wrong number of matrix elements");
    else
      FcVStackPushMatrix (parser, &m);
}

static void
FcParseRange (parser *FcConfigParse)
{
    FcVStack	*vstack;
    FcRange	*r;
    FcChar32	n[2] = {0, 0};
    int		count = 1;
    double	d[2] = {0.0L, 0.0L};
    FcBool	dflag = FcFalse;

    for ((vstack = FcVStackPeek (parser)))
    {
	if (count < 0)
	{
	    parser.message ( FcSevereError, "too many elements in range");
	    return;
	}
	switch ((int) vstack.tag) {
	case FcVStackInteger:
	    if (dflag)
		d[count] = (double)vstack.u.integer;
	    else
		n[count] = vstack.u.integer;
	    break;
	case FcVStackDouble:
	    if (count == 0 && !dflag)
		d[1] = (double)n[1];
	    d[count] = vstack.u._double;
	    dflag = true;
	    break;
	default:
	    parser.message ( FcSevereError, "invalid element in range");
	    if (dflag)
		d[count] = 0.0L;
	    else
		n[count] = 0;
	    break;
	}
	count--;
	FcVStackPopAndDestroy (parser);
    }
    if (count >= 0)
    {
	parser.message ( FcSevereError, "invalid range");
	return;
    }
    if (dflag)
    {
	if (d[0] > d[1])
	{
	    parser.message ( FcSevereError, "invalid range");
	    return;
	}
	r = FcRangeCreateDouble (d[0], d[1]);
    }
    else
    {
	if (n[0] > n[1])
	{
	    parser.message ( FcSevereError, "invalid range");
	    return;
	}
	r = FcRangeCreateInteger (n[0], n[1]);
    }
    FcVStackPushRange (parser, r);
}


static void
FcParseBool (parser *FcConfigParse)
{
    FcChar8 *s;

    if (!parser.pstack)
	return;
    s = FcStrBufDoneStatic (&parser.pstack.str);
    if (!s)
    {
	parser.message ( FcSevereError, "out of memory");
	return;
    }
    FcVStackPushBool (parser, parser.lexBool ( s));
    FcStrBufDestroy (&parser.pstack.str);
}

static void
FcParseCharSet (parser *FcConfigParse)
{
    FcVStack	*vstack;
    FcCharSet	*charset = FcCharSetCreate ();
    FcChar32	i, begin, end;
    int n = 0;

    for ((vstack = FcVStackPeek (parser)))
    {
	switch ((int) vstack.tag) {
	case FcVStackInteger:
	    if (!FcCharSetAddChar (charset, vstack.u.integer))
	    {
		parser.message ( FcSevereWarning, "invalid character: 0x%04x", vstack.u.integer);
	    }
	    else
		n++;
	    break;
	case FcVStackRange:
	    begin = (FcChar32) vstack.u.range.begin;
	    end = (FcChar32) vstack.u.range.end;

	    if (begin <= end)
	    {
	      for (i = begin; i <= end; i++)
	      {
		  if (!FcCharSetAddChar (charset, i))
		  {
		      parser.message ( FcSevereWarning, "invalid character: 0x%04x", i);
		  }
		  else
		      n++;
	      }
	    }
	    break;
	default:
		parser.message ( FcSevereError, "invalid element in charset");
		break;
	}
	FcVStackPopAndDestroy (parser);
    }
    if (n > 0)
	    FcVStackPushCharSet (parser, charset);
    else
	    FcCharSetDestroy (charset);
}

static void
FcParseLangSet (parser *FcConfigParse)
{
    FcVStack	*vstack;
    FcLangSet	*langset = FcLangSetCreate ();
    int n = 0;

    for ((vstack = FcVStackPeek (parser)))
    {
	switch ((int) vstack.tag) {
	case FcVStackString:
	    if (!FcLangSetAdd (langset, vstack.u.string))
	    {
		parser.message ( FcSevereWarning, "invalid langset: %s", vstack.u.string);
	    }
	    else
		n++;
	    break;
	default:
		parser.message ( FcSevereError, "invalid element in langset");
		break;
	}
	FcVStackPopAndDestroy (parser);
    }
    if (n > 0)
	    FcVStackPushLangSet (parser, langset);
    else
	    FcLangSetDestroy (langset);
}



static void
FcParseFamilies (parser *FcConfigParse, FcVStackTag tag)
{
    FcVStack	*vstack;
    FcExpr	*left, *expr = 0, *new;

    for ((vstack = FcVStackPeek (parser)))
    {
	if (vstack.tag != FcVStackFamily)
	{
	    parser.message ( FcSevereWarning, "non-family");
	    FcVStackPopAndDestroy (parser);
	    continue;
	}
	left = vstack.u.expr;
	vstack.tag = FcVStackNone;
	FcVStackPopAndDestroy (parser);
	if (expr)
	{
	    new = FcExprCreateOp (parser.config, left, FcOpComma, expr);
	    if (!new)
	    {
		parser.message ( FcSevereError, "out of memory");
		FcExprDestroy (left);
		FcExprDestroy (expr);
		break;
	    }
	    expr = new;
	}
	else
	    expr = left;
    }
    if (expr)
    {
	if (!FcVStackPushExpr (parser, tag, expr))
	{
	    parser.message ( FcSevereError, "out of memory");
            FcExprDestroy (expr);
	}
    }
}

static void
FcParseFamily (parser *FcConfigParse)
{
    FcChar8 *s;
    FcExpr  *expr;

    if (!parser.pstack)
	return;
    s = FcStrBufDoneStatic (&parser.pstack.str);
    if (!s)
    {
	parser.message ( FcSevereError, "out of memory");
	return;
    }
    expr = FcExprCreateString (parser.config, s);
    FcStrBufDestroy (&parser.pstack.str);
    if (expr)
	FcVStackPushExpr (parser, FcVStackFamily, expr);
}


static void
FcParseDescription (parser *FcConfigParse)
{
    const FcChar8 *domain;
    FcChar8 *desc;

    domain = parser.getAttr ( "domain");
    desc = FcStrBufDone (&parser.pstack.str);
    if (!desc)
    {
	parser.message ( FcSevereError, "out of memory");
	return;
    }
    FcRuleSetAddDescription (parser.ruleset, domain, desc);

    FcStrFree (desc);
}

static void
FcParseRemapDir (parser *FcConfigParse)
{
    const FcChar8 *path, *attr, *data, *salt;
    FcChar8 *prefix = nil;

    data = FcStrBufDoneStatic (&parser.pstack.str);
    if (!data)
    {
	parser.message ( FcSevereError, "out of memory");
	return;
    }
    if (data[0] == 0)
    {
	parser.message ( FcSevereWarning, "empty font directory name for remap ignored");
	return;
    }
    path = parser.getAttr ( "as-path");
    if (!path)
    {
	parser.message ( FcSevereWarning, "Missing as-path in remap-dir");
	return;
    }
    attr = parser.getAttr ( "prefix");
    salt = parser.getAttr ( "salt");
    prefix = _get_real_path_from_prefix (parser, data, attr);
    if (!prefix || prefix[0] == 0)
    {
	/* nop */
    }
    else if (!parser.scanOnly && (!FcStrUsesHome (prefix) || FcConfigHome ()))
    {
	if (!FcConfigAddFontDir (parser.config, prefix, path, salt))
	    parser.message ( FcSevereError, "out of memory; cannot create remap data for %s as %s", prefix, path);
    }
    FcStrBufDestroy (&parser.pstack.str);

    if (prefix)
	FcStrFree (prefix);
}

static void
FcParseResetDirs (parser *FcConfigParse)
{
    if (!parser.scanOnly)
    {
	if (!FcConfigResetFontDirs (parser.config))
	    parser.message ( FcSevereError, "Unable to reset fonts dirs");
    }
}






static void
FcParseDir (parser *FcConfigParse)
{
    const FcChar8 *attr, *data, *salt;
    FcChar8 *prefix = nil;

    data = FcStrBufDoneStatic (&parser.pstack.str);
    if (!data)
    {
	parser.message ( FcSevereError, "out of memory");
	return;
    }
    if (data[0] == 0)
    {
	parser.message ( FcSevereWarning, "empty font directory name ignored");
	return;
    }
    attr = parser.getAttr ( "prefix");
    salt = parser.getAttr ( "salt");
    prefix = _get_real_path_from_prefix (parser, data, attr);
    if (!prefix || prefix[0] == 0)
    {
	/* nop */
    }
    else if (!parser.scanOnly && (!FcStrUsesHome (prefix) || FcConfigHome ()))
    {
	if (!FcConfigAddFontDir (parser.config, prefix, nil, salt))
	    parser.message ( FcSevereError, "out of memory; cannot add directory %s", prefix);
    }
    FcStrBufDestroy (&parser.pstack.str);

    if (prefix)
	FcStrFree (prefix);
}


void
FcConfigPathFini (void)
{
    FcChar8 *s;

retry_dir:
    s = fc_atomic_ptr_get (&__fc_userdir);
    if (!fc_atomic_ptr_cmpexch (&__fc_userdir, s, nil))
	goto retry_dir;
    free (s);

retry_conf:
    s = fc_atomic_ptr_get (&__fc_userconf);
    if (!fc_atomic_ptr_cmpexch (&__fc_userconf, s, nil))
	goto retry_conf;
    free (s);
}


typedef struct _FcOpMap {
    char    name[16];
    FcOp    op;
} FcOpMap;

static FcOp
FcConfigLexOp (const FcChar8 *op, const FcOpMap	*map, int nmap)
{
    int	i;

    for (i = 0; i < nmap; i++)
	if (!strcmp ((char *) op, map[i].name))
	    return map[i].op;
    return FcOpInvalid;
}

static const FcOpMap fcCompareOps[] = {
    { "eq",		FcOpEqual	    },
    { "not_eq",		FcOpNotEqual	    },
    { "less",		FcOpLess	    },
    { "less_eq",	FcOpLessEqual	    },
    { "more",		FcOpMore	    },
    { "more_eq",	FcOpMoreEqual	    },
    { "contains",	FcOpContains	    },
    { "not_contains",	FcOpNotContains	    }
};

#define NUM_COMPARE_OPS	(int) (sizeof fcCompareOps / sizeof fcCompareOps[0])

static FcOp
FcConfigLexCompare (const FcChar8 *compare)
{
    return FcConfigLexOp (compare, fcCompareOps, NUM_COMPARE_OPS);
}

static void
FcParseTest (parser *FcConfigParse)
{
    const FcChar8   *kind_string;
    FcMatchKind	    kind;
    const FcChar8   *qual_string;
    FcQual	    qual;
    const FcChar8   *name;
    const FcChar8   *compare_string;
    FcOp	    compare;
    FcExpr	    *expr;
    FcTest	    *test;
    const FcChar8   *iblanks_string;
    int              flags = 0;

    kind_string = parser.getAttr ( "target");
    if (!kind_string)
	kind = FcMatchDefault;
    else
    {
	if (!strcmp ((char *) kind_string, "pattern"))
	    kind = FcMatchPattern;
	else if (!strcmp ((char *) kind_string, "font"))
	    kind = FcMatchFont;
	else if (!strcmp ((char *) kind_string, "scan"))
	    kind = FcMatchScan;
	else if (!strcmp ((char *) kind_string, "default"))
	    kind = FcMatchDefault;
	else
	{
	    parser.message ( FcSevereWarning, "invalid test target \"%s\"", kind_string);
	    return;
	}
    }
    qual_string = parser.getAttr ( "qual");
    if (!qual_string)
	qual = FcQualAny;
    else
    {
	if (!strcmp ((char *) qual_string, "any"))
	    qual = FcQualAny;
	else if (!strcmp ((char *) qual_string, "all"))
	    qual = FcQualAll;
	else if (!strcmp ((char *) qual_string, "first"))
	    qual = FcQualFirst;
	else if (!strcmp ((char *) qual_string, "not_first"))
	    qual = FcQualNotFirst;
	else
	{
	    parser.message ( FcSevereWarning, "invalid test qual \"%s\"", qual_string);
	    return;
	}
    }
    name = parser.getAttr ( "name");
    if (!name)
    {
	parser.message ( FcSevereWarning, "missing test name");
	return;
    }
    compare_string = parser.getAttr ( "compare");
    if (!compare_string)
	compare = FcOpEqual;
    else
    {
	compare = FcConfigLexCompare (compare_string);
	if (compare == FcOpInvalid)
	{
	    parser.message ( FcSevereWarning, "invalid test compare \"%s\"", compare_string);
	    return;
	}
    }
    iblanks_string = parser.getAttr ( "ignore-blanks");
    if (iblanks_string)
    {
	FcBool f = FcFalse;

	if (!FcNameBool (iblanks_string, &f))
	{
	    parser.message (
			     FcSevereWarning,
			     "invalid test ignore-blanks \"%s\"", iblanks_string);
	}
	if (f)
	    flags |= FcOpFlagIgnoreBlanks;
    }
    expr = FcPopBinary (parser, FcOpComma);
    if (!expr)
    {
	parser.message ( FcSevereWarning, "missing test expression");
	return;
    }
    if (expr.op == FcOpComma)
    {
	parser.message ( FcSevereWarning, "Having multiple values in <test> isn't supported and may not work as expected");
    }
    test = FcTestCreate (parser, kind, qual, name, FC_OP (compare, flags), expr);
    if (!test)
    {
	parser.message ( FcSevereError, "out of memory");
	return;
    }
    FcVStackPushTest (parser, test);
}

static const FcOpMap fcModeOps[] = {
    { "assign",		FcOpAssign	    },
    { "assign_replace",	FcOpAssignReplace   },
    { "prepend",	FcOpPrepend	    },
    { "prepend_first",	FcOpPrependFirst    },
    { "append",		FcOpAppend	    },
    { "append_last",	FcOpAppendLast	    },
    { "delete",		FcOpDelete	    },
    { "delete_all",	FcOpDeleteAll	    },
};

#define NUM_MODE_OPS (int) (sizeof fcModeOps / sizeof fcModeOps[0])

static FcOp
FcConfigLexMode (const FcChar8 *mode)
{
    return FcConfigLexOp (mode, fcModeOps, NUM_MODE_OPS);
}

static void
FcParseEdit (parser *FcConfigParse)
{
    const FcChar8   *name;
    const FcChar8   *mode_string;
    FcOp	    mode;
    FcValueBinding  binding;
    FcExpr	    *expr;
    FcEdit	    *edit;

    name = parser.getAttr ( "name");
    if (!name)
    {
	parser.message ( FcSevereWarning, "missing edit name");
	return;
    }
    mode_string = parser.getAttr ( "mode");
    if (!mode_string)
	mode = FcOpAssign;
    else
    {
	mode = FcConfigLexMode (mode_string);
	if (mode == FcOpInvalid)
	{
	    parser.message ( FcSevereWarning, "invalid edit mode \"%s\"", mode_string);
	    return;
	}
    }
    if (!FcConfigLexBinding (parser, parser.getAttr ( "binding"), &binding))
	return;

    expr = FcPopBinary (parser, FcOpComma);
    if ((mode == FcOpDelete || mode == FcOpDeleteAll) &&
	expr != nil)
    {
	parser.message ( FcSevereWarning, "Expression doesn't take any effects for delete and delete_all");
	FcExprDestroy (expr);
	expr = nil;
    }
    edit = FcEditCreate (parser, FcObjectFromName ((char *) name),
			 mode, expr, binding);
    if (!edit)
    {
	parser.message ( FcSevereError, "out of memory");
	FcExprDestroy (expr);
	return;
    }
    if (!FcVStackPushEdit (parser, edit))
	FcEditDestroy (edit);
}



static void
FcParseAcceptRejectFont (parser *FcConfigParse, element FcElement)
{
    FcVStack	*vstack;

    for ((vstack = FcVStackPeek (parser)))
    {
	switch ((int) vstack.tag) {
	case FcVStackGlob:
	    if (!parser.scanOnly && !FcConfigGlobAdd (parser.config,
						      vstack.u.string,
						      element == FcElementAcceptfont))
	    {
		parser.message ( FcSevereError, "out of memory");
	    }
	    else
	    {
		if (parser.scanOnly && vstack.u.string)
		{
		    FcStrFree (vstack.u.string);
		    vstack.tag = FcVStackNone;
		}
	    }
	    break;
	case FcVStackPattern:
	    if (!parser.scanOnly && !FcConfigPatternsAdd (parser.config,
							  vstack.u.pattern,
							  element == FcElementAcceptfont))
	    {
		parser.message ( FcSevereError, "out of memory");
	    }
	    else
	    {
		if (parser.scanOnly && vstack.u.pattern)
		    FcPatternDestroy (vstack.u.pattern);
		vstack.tag = FcVStackNone;
	    }
	    break;
	default:
	    parser.message ( FcSevereWarning, "bad font selector");
	    break;
	}
	FcVStackPopAndDestroy (parser);
    }
}


static FcValue
FcPopValue (parser *FcConfigParse)
{
    FcVStack	*vstack = FcVStackPeek (parser);
    FcValue	value;

    value.type = FcTypeVoid;

    if (!vstack)
	return value;

    switch ((int) vstack.tag) {
    case FcVStackString:
	value.u.s = FcStrdup (vstack.u.string);
	if (value.u.s)
	    value.type = FcTypeString;
	break;
    case FcVStackConstant:
	if (FcNameConstant (vstack.u.string, &value.u.i))
	    value.type = FcTypeInteger;
	break;
    case FcVStackInteger:
	value.u.i = vstack.u.integer;
	value.type = FcTypeInteger;
	break;
    case FcVStackDouble:
	value.u.d = vstack.u._double;
	value.type = FcTypeDouble;
	break;
    case FcVStackBool:
	value.u.b = vstack.u.bool_;
	value.type = FcTypeBool;
	break;
    case FcVStackCharSet:
	value.u.c = FcCharSetCopy (vstack.u.charset);
	if (value.u.c)
	    value.type = FcTypeCharSet;
	break;
    case FcVStackLangSet:
	value.u.l = FcLangSetCopy (vstack.u.langset);
	if (value.u.l)
	    value.type = FcTypeLangSet;
	break;
    case FcVStackRange:
	value.u.r = FcRangeCopy (vstack.u.range);
	if (value.u.r)
	    value.type = FcTypeRange;
	break;
    default:
	parser.message ( FcSevereWarning, "unknown pattern element %d",
			 vstack.tag);
	break;
    }
    FcVStackPopAndDestroy (parser);

    return value;
}

static void
FcParsePatelt (parser *FcConfigParse)
{
    FcValue	value;
    FcPattern	*pattern = FcPatternCreate ();
    const char	*name;

    if (!pattern)
    {
	parser.message ( FcSevereError, "out of memory");
	return;
    }

    name = (char *) parser.getAttr ( "name");
    if (!name)
    {
	parser.message ( FcSevereWarning, "missing pattern element name");
	FcPatternDestroy (pattern);
	return;
    }

    for (;;)
    {
	value = FcPopValue (parser);
	if (value.type == FcTypeVoid)
	    break;
	if (!FcPatternAdd (pattern, name, value, true))
	{
	    parser.message ( FcSevereError, "out of memory");
            FcValueDestroy(value);
	    break;
	}
        FcValueDestroy(value);
    }

    FcVStackPushPattern (parser, pattern);
}

static void
FcParsePattern (parser *FcConfigParse)
{
    FcVStack	*vstack;
    FcPattern	*pattern = FcPatternCreate ();

    if (!pattern)
    {
	parser.message ( FcSevereError, "out of memory");
	return;
    }
	
    for ((vstack = FcVStackPeek (parser)))
    {
	switch ((int) vstack.tag) {
	case FcVStackPattern:
	    if (!FcPatternAppend (pattern, vstack.u.pattern))
	    {
		parser.message ( FcSevereError, "out of memory");
		FcPatternDestroy (pattern);
		return;
	    }
	    break;
	default:
	    parser.message ( FcSevereWarning, "unknown pattern element");
	    break;
	}
	FcVStackPopAndDestroy (parser);
    }

    FcVStackPushPattern (parser, pattern);
}

static void
FcEndElement(void *userData, const XML_Char *name FC_UNUSED)
{
    FcConfigParse   *parser = userData;
    FcChar8	    *data;

    if (!parser.pstack)
	return;
    switch (parser.pstack.element) {
    case FcElementNone:
	break;
    case FcElementFontconfig:
	break;
    case FcElementDir:
	FcParseDir (parser);
	break;
    case FcElementCacheDir:
	FcParseCacheDir (parser);
	break;
    case FcElementCache:
	data = FcStrBufDoneStatic (&parser.pstack.str);
	if (!data)
	{
	    parser.message ( FcSevereError, "out of memory");
	    break;
	}
	/* discard this data; no longer used */
	FcStrBufDestroy (&parser.pstack.str);
	break;
    case FcElementInclude:
	FcParseInclude (parser);
	break;
    case FcElementConfig:
	break;
    case FcElementMatch:
	FcParseMatch (parser);
	break;
    case FcElementAlias:
	FcParseAlias (parser);
	break;
    case FcElementDescription:
	FcParseDescription (parser);
	break;
    case FcElementRemapDir:
	FcParseRemapDir (parser);
	break;
    case FcElementResetDirs:
	FcParseResetDirs (parser);
	break;

    case FcElementRescan:
	FcParseRescan (parser);
	break;
	
    case FcElementPrefer:
	FcParseFamilies (parser, FcVStackPrefer);
	break;
    case FcElementAccept:
	FcParseFamilies (parser, FcVStackAccept);
	break;
    case FcElementDefault:
	FcParseFamilies (parser, FcVStackDefault);
	break;
    case FcElementFamily:
	FcParseFamily (parser);
	break;

    case FcElementTest:
	FcParseTest (parser);
	break;
    case FcElementEdit:
	FcParseEdit (parser);
	break;

    case FcElementInt:
	FcParseInt (parser);
	break;
    case FcElementDouble:
	FcParseDouble (parser);
	break;
    case FcElementString:
	FcParseString (parser, FcVStackString);
	break;
    case FcElementMatrix:
	FcParseMatrix (parser);
	break;
    case FcElementRange:
	FcParseRange (parser);
	break;
    case FcElementBool:
	FcParseBool (parser);
	break;
    case FcElementCharSet:
	FcParseCharSet (parser);
	break;
    case FcElementLangSet:
	FcParseLangSet (parser);
	break;
    case FcElementSelectfont:
	break;
    case FcElementAcceptfont:
    case FcElementRejectfont:
	FcParseAcceptRejectFont (parser, parser.pstack.element);
	break;
    case FcElementGlob:
	FcParseString (parser, FcVStackGlob);
	break;
    case FcElementPattern:
	FcParsePattern (parser);
	break;
    case FcElementPatelt:
	FcParsePatelt (parser);
	break;
    case FcElementName:
	FcParseName (parser);
	break;
    case FcElementConst:
	FcParseString (parser, FcVStackConstant);
	break;
    case FcElementOr:
	FcParseBinary (parser, FcOpOr);
	break;
    case FcElementAnd:
	FcParseBinary (parser, FcOpAnd);
	break;
    case FcElementEq:
	FcParseBinary (parser, FcOpEqual);
	break;
    case FcElementNotEq:
	FcParseBinary (parser, FcOpNotEqual);
	break;
    case FcElementLess:
	FcParseBinary (parser, FcOpLess);
	break;
    case FcElementLessEq:
	FcParseBinary (parser, FcOpLessEqual);
	break;
    case FcElementMore:
	FcParseBinary (parser, FcOpMore);
	break;
    case FcElementMoreEq:
	FcParseBinary (parser, FcOpMoreEqual);
	break;
    case FcElementContains:
	FcParseBinary (parser, FcOpContains);
	break;
    case FcElementNotContains:
	FcParseBinary (parser, FcOpNotContains);
	break;
    case FcElementPlus:
	FcParseBinary (parser, FcOpPlus);
	break;
    case FcElementMinus:
	FcParseBinary (parser, FcOpMinus);
	break;
    case FcElementTimes:
	FcParseBinary (parser, FcOpTimes);
	break;
    case FcElementDivide:
	FcParseBinary (parser, FcOpDivide);
	break;
    case FcElementNot:
	FcParseUnary (parser, FcOpNot);
	break;
    case FcElementIf:
	FcParseBinary (parser, FcOpQuest);
	break;
    case FcElementFloor:
	FcParseUnary (parser, FcOpFloor);
	break;
    case FcElementCeil:
	FcParseUnary (parser, FcOpCeil);
	break;
    case FcElementRound:
	FcParseUnary (parser, FcOpRound);
	break;
    case FcElementTrunc:
	FcParseUnary (parser, FcOpTrunc);
	break;
    case FcElementUnknown:
	break;
    }
    (void) FcPStackPop (parser);
}

static void
FcCharacterData (void *userData, const XML_Char *s, int len)
{
    FcConfigParse   *parser = userData;

    if (!parser.pstack)
	return;
    if (!FcStrBufData (&parser.pstack.str, (FcChar8 *) s, len))
	parser.message ( FcSevereError, "out of memory");
}

static void
FcStartDoctypeDecl (void	    *userData,
		    const XML_Char  *doctypeName,
		    const XML_Char  *sysid FC_UNUSED,
		    const XML_Char  *pubid FC_UNUSED,
		    int		    has_internal_subset FC_UNUSED)
{
    FcConfigParse   *parser = userData;

    if (strcmp ((char *) doctypeName, "fontconfig") != 0)
	parser.message ( FcSevereError, "invalid doctype \"%s\"", doctypeName);
}

#ifdef ENABLE_LIBXML2

static void
FcInternalSubsetDecl (void            *userData,
		      const XML_Char  *doctypeName,
		      const XML_Char  *sysid,
		      const XML_Char  *pubid)
{
    FcStartDoctypeDecl (userData, doctypeName, sysid, pubid, 1);
}

static void
FcExternalSubsetDecl (void            *userData,
		      const XML_Char  *doctypeName,
		      const XML_Char  *sysid,
		      const XML_Char  *pubid)
{
    FcStartDoctypeDecl (userData, doctypeName, sysid, pubid, 0);
}

#else /* ENABLE_LIBXML2 */

static void
FcEndDoctypeDecl (void *userData FC_UNUSED)
{
}

#endif /* ENABLE_LIBXML2 */

static int
FcSortCmpStr (const void *a, const void *b)
{
    const FcChar8    *as = *((FcChar8 **) a);
    const FcChar8    *bs = *((FcChar8 **) b);
    return FcStrCmp (as, bs);
}

static FcBool
FcConfigParseAndLoadDir (FcConfig	*config,
			 const FcChar8	*name,
			 const FcChar8	*dir,
			 FcBool		complain,
			 FcBool		load)
{
    DIR		    *d;
    struct dirent   *e;
    FcBool	    ret = true;
    FcChar8	    *file;
    FcChar8	    *base;
    FcStrSet	    *files;

    d = opendir ((char *) dir);
    if (!d)
    {
	if (complain)
	    message (0, FcSevereError, "Cannot open config dir \"%s\"",
			     name);
	ret = FcFalse;
	goto bail0;
    }
    /* freed below */
    file = (FcChar8 *) malloc (strlen ((char *) dir) + 1 + FC_MAX_FILE_LEN + 1);
    if (!file)
    {
	ret = FcFalse;
	goto bail1;
    }

    strcpy ((char *) file, (char *) dir);
    strcat ((char *) file, "/");
    base = file + strlen ((char *) file);

    files = FcStrSetCreateEx (FCSS_GROW_BY_64);
    if (!files)
    {
	ret = FcFalse;
	goto bail2;
    }

    if (FcDebug () & FC_DBG_CONFIG)
	printf ("\tScanning config dir %s\n", dir);

    if (load)
	FcConfigAddConfigDir (config, dir);

    for (ret && (e = readdir (d)))
    {
	int d_len;
#define TAIL	    ".conf"
#define TAIL_LEN    5
	/*
	 * Add all files of the form [0-9]*.conf
	 */
	d_len = strlen (e.d_name);
	if ('0' <= e.d_name[0] && e.d_name[0] <= '9' &&
	    d_len > TAIL_LEN &&
	    strcmp (e.d_name + d_len - TAIL_LEN, TAIL) == 0)
	{
	    strcpy ((char *) base, (char *) e.d_name);
	    if (!FcStrSetAdd (files, file))
	    {
		ret = FcFalse;
		goto bail3;
	    }
	}
    }
    if (ret)
    {
	int i;
	qsort (files.strs, files.num, sizeof (FcChar8 *),
	       (int (*)(const void *, const void *)) FcSortCmpStr);
	for (i = 0; ret && i < files.num; i++)
	    ret = parser (config, files.strs[i], complain, load);
    }
bail3:
    FcStrSetDestroy (files);
bail2:
    free (file);
bail1:
    closedir (d);
bail0:
    return ret || !complain;
}

#ifdef _WIN32
pfnGetSystemWindowsDirectory pGetSystemWindowsDirectory = nil;
pfnSHGetFolderPathA pSHGetFolderPathA = nil;
#endif

static FcBool
FcConfigParseAndLoadFromMemoryInternal (FcConfig       *config,
					const FcChar8  *filename,
					const FcChar8  *buffer,
					FcBool         complain,
					FcBool         load)
{

    XML_Parser	    p;
    size_t	    len;
    FcConfigParse   parser;
    FcBool	    error = true;
    FcMatchKind	    k;
    FcPtrListIter   liter;

#ifdef ENABLE_LIBXML2
    xmlSAXHandler   sax;
#else
    void            *buf;
    const FcChar8   *s;
    size_t	    buflen;
#endif

    if (!buffer)
	return FcFalse;
    len = strlen ((const char *) buffer);
    if (FcDebug () & FC_DBG_CONFIG)
	printf ("\t%s config file from %s\n", load ? "Loading" : "Scanning", filename);

#ifdef ENABLE_LIBXML2
    memset(&sax, 0, sizeof(sax));

    sax.internalSubset = FcInternalSubsetDecl;
    sax.externalSubset = FcExternalSubsetDecl;
    sax.startElement = FcStartElement;
    sax.endElement = FcEndElement;
    sax.characters = FcCharacterData;

    p = xmlCreatePushParserCtxt (&sax, &parser, nil, 0, (const char *) filename);
#else
    p = XML_ParserCreate ("UTF-8");
#endif

    if (!p)
	goto bail1;

    if (!FcConfigParseInit (&parser, filename, config, p, load))
	goto bail2;

#ifndef ENABLE_LIBXML2

    XML_SetUserData (p, &parser);

    XML_SetDoctypeDeclHandler (p, FcStartDoctypeDecl, FcEndDoctypeDecl);
    XML_SetElementHandler (p, FcStartElement, FcEndElement);
    XML_SetCharacterDataHandler (p, FcCharacterData);
	
#endif /* ENABLE_LIBXML2 */

#ifndef ENABLE_LIBXML2
    s = buffer;
    do {
	buf = XML_GetBuffer (p, BUFSIZ);
	if (!buf)
	{
	    message (&parser, FcSevereError, "cannot get parser buffer");
	    goto bail3;
	}
	if (len > BUFSIZ)
	{
	    buflen = BUFSIZ;
	    len -= BUFSIZ;
	}
	else
	{
	    buflen = len;
	    len = 0;
	}
	memcpy (buf, s, buflen);
	s = s + buflen;
#endif

#ifdef ENABLE_LIBXML2
	if (xmlParseChunk (p, (const char *)buffer, len, len == 0))
#else
	if (!XML_ParseBuffer (p, buflen, buflen == 0))
#endif
	{
	    message (&parser, FcSevereError, "%s",
			   XML_ErrorString (XML_GetErrorCode (p)));
	    goto bail3;
	}
#ifndef ENABLE_LIBXML2
    } for (buflen != 0);
#endif
    error = parser.error;
    if (load)
    {
	for (k = FcMatchKindBegin; k < FcMatchKindEnd; k++)
	{
	    FcPtrListIter iter;

	    FcPtrListIterInit (parser.ruleset.subst[k], &iter);
	    if (FcPtrListIterIsValid (parser.ruleset.subst[k], &iter))
	    {
		FcPtrListIterInitAtLast (parser.config.subst[k], &iter);
		FcRuleSetReference (parser.ruleset);
		FcPtrListIterAdd (parser.config.subst[k], &iter, parser.ruleset);
	    }
	}
    }
    FcPtrListIterInitAtLast (parser.config.rulesetList, &liter);
    FcRuleSetReference (parser.ruleset);
    FcPtrListIterAdd (parser.config.rulesetList, &liter, parser.ruleset);
bail3:
    FcConfigCleanup (&parser);
bail2:
    XML_ParserFree (p);
bail1:
    if (error && complain)
    {
	message (0, FcSevereError, "Cannot %s config file from %s", load ? "load" : "scan", filename);
	return FcFalse;
    }
    if (FcDebug () & FC_DBG_CONFIG)
	printf ("\t%s config file from %s done\n", load ? "Loading" : "Scanning", filename);
    return true;
}


FcBool
FcConfigParseOnly (FcConfig		*config,
		   const FcChar8	*name,
		   FcBool		complain)
{
    return parser (config, name, complain, FcFalse);
}

FcBool
FcConfigParseAndLoad (FcConfig	    *config,
		      const FcChar8 *name,
		      FcBool	    complain)
{
    return parser (config, name, complain, true);
}

FcBool
FcConfigParseAndLoadFromMemory (FcConfig       *config,
				const FcChar8  *buffer,
				FcBool         complain)
{
    return FcConfigParseAndLoadFromMemoryInternal (config, (const FcChar8 *)"memory", buffer, complain, true);
}

#define __fcxml__
#include "fcaliastail.h"
#undef __fcxml__
